<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Legend of Bahamut Strategy - Battle & Move Fixed</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=DotGothic16&display=swap');

        body {
            font-family: 'DotGothic16', sans-serif;
            background-color: #1a1a1a;
            color: #e0e0e0;
            overflow: hidden;
            margin: 0;
            touch-action: manipulation;
        }

        .hex {
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            transition: all 0.2s;
        }

        .hex-active:hover {
            filter: brightness(1.5);
            cursor: pointer;
        }

        .scanline {
            width: 100%;
            height: 100%;
            position: fixed;
            top: 0;
            left: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 4px, 3px 100%;
            pointer-events: none;
            z-index: 100;
        }

        .pixel-border {
            border: 4px double #4a5568;
            background: rgba(0, 0, 0, 0.85);
        }

        @keyframes select-pulse {
            0% {
                filter: drop-shadow(0 0 5px cyan);
            }

            50% {
                filter: drop-shadow(0 0 20px cyan);
            }

            100% {
                filter: drop-shadow(0 0 5px cyan);
            }
        }

        .recruit-item:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .custom-scrollbar::-webkit-scrollbar {
            width: 6px;
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: rgba(100, 100, 100, 0.5);
            border-radius: 10px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: rgba(150, 150, 150, 0.8);
        }
    </style>
</head>

<body>
    <div class="scanline"></div>

    <!-- VIEW: UI Elements -->
    <div id="ui-layer" class="fixed inset-0 z-50 pointer-events-none">

        <!-- çµæœãƒ¢ãƒ¼ãƒ€ãƒ« -->
        <div id="modal-layer"
            class="absolute inset-0 bg-black/80 flex items-center justify-center hidden pointer-events-auto text-white z-[200]">
            <div class="bg-gray-900 border-4 border-double border-white p-12 max-w-lg w-full text-center shadow-2xl">
                <h3 id="modal-title" class="text-4xl font-bold mb-6 text-yellow-500">ç¢ºèª</h3>
                <p id="modal-body" class="text-xl mb-10 leading-relaxed"></p>
                <div id="modal-footer" class="flex justify-center gap-6"></div>
            </div>
        </div>

        <!-- çµæœãƒ¢ãƒ¼ãƒ€ãƒ« -->
        <div id="modal-layer"
            class="absolute inset-0 bg-black/80 flex items-center justify-center hidden pointer-events-auto text-white">
            <div class="bg-gray-900 border-4 border-double border-white p-12 max-w-lg w-full text-center shadow-2xl">
                <h2 id="modal-title" class="text-5xl font-bold mb-8 text-yellow-500 uppercase">Result</h2>
                <p id="modal-body" class="mb-12 text-2xl leading-relaxed text-gray-200 font-bold"></p>
                <div id="modal-footer" class="flex justify-center gap-8"></div>
            </div>
        </div>


        <!-- æœ€å‰é¢ã«è¡¨ç¤ºã™ã¹ãè¦ç´  -->
        <div id="top-elements" class="absolute inset-0 pointer-events-none z-[110]">
            <!-- ã‚¿ãƒ¼ãƒ³è¡¨ç¤ºï¼ˆæˆ¦ç•¥ãƒãƒƒãƒ—ä»¥å¤–ã§ä½¿ç”¨ï¼‰ -->
            <div id="turn-indicator"
                class="absolute top-4 left-1/2 -translate-x-1/2 px-12 py-2 bg-black/80 border-2 border-white hidden pointer-events-auto shadow-2xl flex flex-col items-center">
                <div id="turn-display-overlay" class="text-sm text-yellow-500 font-bold mb-1">ç¬¬1ã‚¿ãƒ¼ãƒ³</div>
                <p id="turn-text" class="text-3xl font-bold tracking-widest text-center uppercase text-white">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¿ãƒ¼ãƒ³
                </p>
            </div>

            <!-- ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒœãƒƒã‚¯ã‚¹ -->
            <div id="message-box"
                class="absolute bottom-10 left-1/2 -translate-x-1/2 w-4/5 max-w-2xl bg-black/95 border-4 border-double border-gray-500 p-6 opacity-0 transition-opacity pointer-events-auto shadow-2xl">
                <p id="message-text"
                    class="text-xl md:text-2xl leading-relaxed whitespace-pre-wrap text-white font-bold text-center">
                </p>
            </div>
        </div>
    </div>

    <!-- ã‚¨ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ç”»é¢ -->
    <div id="screen-ending"
        class="hidden flex flex-col items-center justify-center h-screen bg-black text-white p-8 relative overflow-hidden">
        <div class="absolute inset-0 bg-gradient-to-b from-blue-900/20 to-black pointer-events-none"></div>
        <div id="ending-vfx" class="absolute inset-0 pointer-events-none opacity-50"></div>

        <div class="relative z-10 text-center scale-110">
            <h2 id="ending-title"
                class="text-8xl font-bold mb-12 text-yellow-500 uppercase tracking-tighter drop-shadow-[0_0_30px_rgba(234,179,8,0.5)]">
                VICTORY</h2>
            <div class="pixel-border p-12 mb-16 max-w-3xl bg-black/60 shadow-2xl">
                <p id="ending-body" class="text-3xl leading-relaxed text-gray-200 font-bold"></p>
            </div>
            <button onclick="location.reload()"
                class="px-20 py-8 bg-gradient-to-r from-blue-900 to-blue-700 hover:from-blue-700 hover:to-blue-500 border-4 border-white transition-all text-4xl font-bold shadow-[0_0_50px_rgba(0,0,0,0.5)] hover:scale-105 active:translate-y-1">
                ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ã¸æˆ»ã‚‹
            </button>
        </div>
    </div>

    <!-- MAIN SCREENS -->
    <div id="screen-title" class="flex flex-col items-center justify-center h-screen relative">
        <h1
            class="text-8xl mb-8 font-bold text-transparent bg-clip-text bg-gradient-to-b from-gray-200 to-gray-600 uppercase tracking-tighter text-center">
            Bahamut Strategy</h1>
        <p class="mb-16 text-3xl text-gray-400 italic font-bold text-center">ã€œ å¤§é™¸çµ±ä¸€ï¼šæœ¬æ ¼ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ ã€œ</p>
        <div class="flex gap-4">
            <button onclick="Controller.startFlow()"
                class="px-16 py-6 bg-red-900 hover:bg-red-700 border-2 border-white transition-all text-4xl font-bold shadow-2xl hover:scale-105 text-white">START
                GAME</button>
            <button onclick="Controller.loadGame()"
                class="px-16 py-6 bg-blue-900 hover:bg-blue-700 border-2 border-white transition-all text-4xl font-bold shadow-2xl hover:scale-105 text-white">LOAD
                GAME</button>
        </div>
        <div class="mt-8 flex gap-4 pointer-events-auto">
            <button onclick="TestSuite.runAll()"
                class="px-4 py-2 bg-gray-800 text-gray-500 text-xs hover:text-white border border-gray-700 transition-colors">Run
                System Tests</button>
        </div>
    </div>

    <!-- ãƒãƒƒãƒ—é¸æŠç”»é¢ -->
    <div id="screen-map-select" class="hidden flex-col items-center justify-center min-h-screen p-8 bg-black/95">
        <h2 class="text-6xl mb-12 font-bold text-center text-yellow-500 uppercase tracking-widest">æˆ¦åœ°ã‚’é¸æŠã›ã‚ˆ</h2>
        <div id="map-flow-list" class="flex flex-wrap justify-center gap-10 w-full mb-12"></div>
        <div class="flex justify-center gap-6">
            <button onclick="View.changeScreen('title')"
                class="px-12 py-4 bg-gray-900 hover:bg-gray-700 border-2 border-gray-500 text-2xl font-bold shadow-xl text-white transition-all">æˆ»ã‚‹</button>
        </div>
    </div>

    <div id="screen-select"
        class="hidden flex-col items-center justify-center min-h-screen p-8 bg-black/95 overflow-y-auto">
        <h2 class="text-5xl mb-16 font-bold text-center text-white italic tracking-widest uppercase">ãƒã‚¹ã‚¿ãƒ¼ã‚’é¸æŠã›ã‚ˆ</h2>
        <div class="flex flex-wrap justify-center gap-10 w-full mb-12"></div>
        <div class="flex justify-center gap-6">
            <button onclick="View.changeScreen('map-select')"
                class="px-12 py-4 bg-gray-900 hover:bg-gray-700 border-2 border-gray-500 text-2xl font-bold shadow-xl text-white transition-all">æˆ»ã‚‹</button>
        </div>
    </div>

    <div id="screen-map" class="hidden flex flex-col h-screen bg-black overflow-hidden select-none">
        <!-- HEADER: æˆ¦ç•¥æŒ‡ä»¤éƒ¨ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ -->
        <header
            class="relative h-20 bg-gray-900 border-b-2 border-gray-700 flex items-center justify-between px-8 shrink-0 z-[60] shadow-2xl">
            <div class="flex items-center gap-10">
                <!-- æŒ‡å°è€…æƒ…å ± -->
                <div class="flex flex-col">
                    <div class="text-[10px] text-gray-500 uppercase tracking-widest font-bold mb-1">æœ€é«˜å¸ä»¤å®˜</div>
                    <div id="master-name"
                        class="text-2xl text-yellow-500 font-black tracking-tighter uppercase leading-none"></div>
                    <div id="master-alignment"
                        class="text-[10px] text-gray-400 mt-1 uppercase font-bold tracking-widest opacity-50"></div>
                </div>

                <div class="h-12 w-[2px] bg-gradient-to-b from-transparent via-gray-700 to-transparent"></div>

                <!-- çµ±è¨ˆæƒ…å ± -->
                <div class="flex gap-10">
                    <div class="flex flex-col">
                        <div class="text-[10px] text-blue-500 uppercase font-black tracking-widest mb-1">æ”¯é…æ‹ ç‚¹æ•°</div>
                        <div id="castle-count-display" class="text-2xl text-white font-mono font-bold leading-none">0/0
                        </div>
                    </div>
                    <div class="flex flex-col">
                        <div class="text-[10px] text-green-500 uppercase font-black tracking-widest mb-1">å±•é–‹éƒ¨éšŠæ•°</div>
                        <div id="army-total-display" class="text-2xl text-white font-mono font-bold leading-none">0/0
                        </div>
                    </div>
                    <div class="flex flex-col">
                        <div class="text-[10px] text-yellow-500 uppercase font-black tracking-widest mb-1">å›½åº«è³‡é‡‘</div>
                        <div id="gold-amount"
                            class="text-2xl text-yellow-400 font-mono font-black leading-none text-white">500G</div>
                    </div>
                </div>
            </div>

            <!-- ç¾åœ¨ã®ã‚¿ãƒ¼ãƒ³ -->
            <div class="absolute inset-0 flex flex-col items-center justify-center pointer-events-none">
                <div id="turn-display" class="text-xs text-yellow-600 font-black uppercase tracking-[0.3em] mb-1">ç¬¬1ã‚¿ãƒ¼ãƒ³
                </div>
                <p id="turn-text-map"
                    class="text-3xl font-black italic uppercase tracking-tighter text-white drop-shadow-[0_0_10px_rgba(255,255,255,0.3)]">
                    è‡ªè»ãƒ•ã‚§ãƒ¼ã‚º</p>
            </div>

            <!-- ã‚·ã‚¹ãƒ†ãƒ æ“ä½œ -->
            <div id="save-load-group" class="flex gap-4 items-center">
                <button onclick="Controller.saveGame()"
                    class="px-6 py-2 bg-gray-800 hover:bg-gray-700 border border-gray-600 text-xs font-bold transition-all text-white">ã‚¯ã‚¤ãƒƒã‚¯ã‚»ãƒ¼ãƒ–</button>
                <button onclick="Controller.loadGame()"
                    class="px-6 py-2 bg-gray-800 hover:bg-gray-700 border border-gray-600 text-xs font-bold transition-all text-white">ã‚¯ã‚¤ãƒƒã‚¯ãƒ­ãƒ¼ãƒ‰</button>
            </div>
        </header>

        <div class="flex flex-1 overflow-hidden relative">
            <!-- BODY: æˆ¦åŸŸãƒãƒƒãƒ— -->
            <main class="flex-1 relative bg-green-950/20 overflow-hidden">
                <canvas id="map-canvas" class="w-full h-full cursor-crosshair blur-[0.3px]"></canvas>

                <!-- æ‹ ç‚¹æƒ…å ±ãƒ»è«œå ±ãƒ‘ãƒãƒ« (ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤) -->
                <div id="base-menu"
                    class="absolute top-4 left-4 bottom-4 w-[675px] max-w-[98vw] bg-gray-900/90 border-2 border-gray-700 flex flex-col shrink-0 z-50 overflow-hidden rounded-xl shadow-2xl backdrop-blur-sm hidden">
                    <div class="p-4 bg-black/60 border-b border-gray-800 flex justify-between items-center shrink-0">
                        <div class="flex flex-col">
                            <div class="text-[10px] text-gray-400 uppercase font-black tracking-[0.2em]">æˆ¦åŸŸæˆ¦ç•¥æƒ…å ±ãƒ‘ãƒãƒ«</div>
                            <h2 id="base-menu-title"
                                class="text-2xl text-yellow-500 font-black tracking-tighter uppercase leading-tight">
                                æ‹ ç‚¹ã‚’é¸æŠã—ã¦ãã ã•ã„</h2>
                        </div>
                        <button onclick="View.clearBaseMenu()"
                            class="text-gray-500 hover:text-white transition-colors text-2xl bg-white/10 w-8 h-8 rounded-full flex items-center justify-center">âœ•</button>
                    </div>

                    <div class="flex-1 overflow-y-auto p-4 flex flex-col gap-4 custom-scrollbar">
                        <!-- åŸºæœ¬çµ±è¨ˆ -->

                        <!-- ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒã‚¦ãƒˆ -->
                        <button id="btn-create-army"
                            class="w-full py-3 bg-purple-900 hover:bg-purple-700 border border-purple-400 text-lg font-black uppercase tracking-widest shadow-lg transition-all transform active:scale-95 disabled:opacity-30 disabled:grayscale text-white rounded">
                            æ–°è¦éƒ¨éšŠã‚’å±•é–‹
                        </button>

                        <div class="h-px bg-gray-700/50 w-full my-1"></div>

                        <!-- é§ç•™éƒ¨éšŠãƒªã‚¹ãƒˆ -->
                        <h3 class="text-[10px] text-gray-500 uppercase font-black tracking-[0.3em]">é§ç•™ä¸­ã®éƒ¨éšŠä¸€è¦§</h3>
                        <div id="base-menu-content" class="flex flex-col gap-3"></div>
                        <div id="no-unit-message"
                            class="py-12 text-center border-2 border-dashed border-gray-800 rounded-lg text-gray-600 text-xs font-black uppercase tracking-widest italic">
                            é§ç•™éƒ¨éšŠãªã—</div>
                    </div>
                </div>
            </main>

            <!-- RIGHT SIDEBAR: ã‚³ãƒãƒ³ãƒ‰ãƒœã‚¿ãƒ³ã®ã¿ -->
            <aside id="command-sidebar"
                class="w-24 bg-gray-950 border-l border-gray-800 flex flex-col justify-end items-center pb-4 z-[55] shadow-xl">
                <button id="btn-end-strategic-turn" onclick="Controller.endStrategicTurn()"
                    class="w-20 py-8 bg-gradient-to-b from-red-800 to-red-950 hover:from-red-700 hover:to-red-900 border-2 border-red-600 text-white font-black uppercase tracking-widest shadow-[0_0_15px_rgba(220,38,38,0.5)] transition-all transform active:scale-95 rounded-lg flex flex-col items-center gap-2 hidden group">
                    <span class="text-sm writing-vertical-rl">ã‚¿ãƒ¼ãƒ³çµ‚äº†</span>
                    <span class="text-2xl">ğŸ›‘</span>
                </button>
            </aside>
        </div>

        <!-- FOOTER: æŒ‡ä»¤ã‚³ãƒãƒ³ãƒ‰ -->
        <footer
            class="h-16 bg-gray-950 border-t-2 border-gray-700 flex items-center justify-between px-8 shrink-0 z-[60]">
            <div class="flex items-center gap-6">
                <div
                    class="p-2 bg-yellow-900/10 border border-yellow-900/30 rounded text-yellow-700 text-[10px] font-black uppercase">
                    ä½œæˆ¦åï¼šå¤§é™¸çµ±ä¸€ä½œæˆ¦</div>
                <div class="text-gray-700 text-[10px] font-bold uppercase tracking-widest">çŠ¶æ³ï¼šä½œæˆ¦è¡Œå‹•ä¸­</div>
            </div>

            <!-- FOOTER: æŒ‡ä»¤ã‚³ãƒãƒ³ãƒ‰ (ãƒœã‚¿ãƒ³ç§»å‹•æ¸ˆã¿) -->
            <button class="hidden"></button>

            <div class="text-gray-700 text-[8px] font-bold uppercase tracking-widest text-right">
                å…¨ã¦ã®æˆ¦ç•¥é€šä¿¡ã¯<br>ãƒãƒãƒ ãƒ¼ãƒˆãƒ»ãƒªãƒ³ã‚¯ã«ã‚ˆã‚Šæš—å·åŒ–ã•ã‚Œã¦ã„ã¾ã™
            </div>
        </footer>
    </div>

    <div id="screen-battle" class="hidden flex flex-col items-center justify-center h-screen bg-slate-900">
        <div class="mb-8 flex gap-16">
            <div id="p1-stats" class="text-4xl text-blue-400 font-bold uppercase tracking-wider">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼éƒ¨éšŠ</div>
            <div class="text-white text-2xl font-bold opacity-30 italic self-center">VS</div>
            <div id="p2-stats" class="text-4xl text-red-400 font-bold uppercase tracking-wider">æ•µå‹¢åŠ›éƒ¨éšŠ</div>
        </div>
        <div id="battle-grid" class="relative scale-110"></div>
        <div class="mt-16 flex gap-10">
            <button id="battle-end-turn-btn" onclick="Controller.battleEndTurnOrder()"
                class="px-12 py-4 bg-blue-800 hover:bg-blue-600 border-2 border-white transition-colors text-2xl font-bold rounded-lg shadow-xl pointer-events-auto text-white">ã‚¿ãƒ¼ãƒ³çµ‚äº†</button>
            <button onclick="Controller.showEscapeConfirm()"
                class="px-12 py-4 bg-gray-800 hover:bg-gray-600 border-2 border-white transition-colors text-2xl font-bold rounded-lg shadow-xl pointer-events-auto text-white">æ’¤é€€</button>
        </div>
    </div>

    <script>
        /**
         * MODEL: å®šç¾©ã¨çŠ¶æ…‹ç®¡ç†
         */
        const Model = {
            MAX_UNITS: 5,
            MAX_ARMIES: 8,
            ARMY_COST: 500,
            UNIT_SPEED: 10.0, // é€²è»ã‚¹ãƒ”ãƒ¼ãƒ‰ã‚¢ãƒƒãƒ—
            RANK_UP_XP: 50, // ãƒ©ãƒ³ã‚¯ã‚¢ãƒƒãƒ—ã«å¿…è¦ãªçµŒé¨“å€¤
            RANKS: ['E', 'D', 'C', 'B', 'A', 'S'],

            MASTERS: [
                { id: 'knight', name: 'ã‚¸ãƒ¼ã‚¯', alignment: 'LAW', color: '#4466ff', emoji: 'ğŸ°', desc: 'è–é¨å£«ã€‚é˜²å¾¡ã¨è¿‘æ¥æˆ¦é—˜ã«å„ªã‚Œã‚‹ãƒãƒ©ãƒ³ã‚¹å‹ã€‚' },
                { id: 'mage', name: 'ã‚¢ãƒ¼ã‚·ã‚§', alignment: 'NEUTRAL', color: '#44ff66', emoji: 'ğŸ§', desc: 'å¥³ç‹ã€‚é è·é›¢é­”æ³•ã¨æ©Ÿå‹•åŠ›ã‚’æŒã¤ã‚¨ãƒ«ãƒ•è»ã€‚' },
                { id: 'demon', name: 'ã‚¯ãƒªãƒ ã‚¾ãƒ³', alignment: 'CHAOS', color: '#ff4444', emoji: 'ğŸ‘¹', desc: 'é­”ç‹ã€‚åœ§å€’çš„ãªæ”»æ’ƒåŠ›ã§æ•µã‚’ç²‰ç •ã™ã‚‹ã€‚' }
            ],

            FACTION_UNITS: {
                'knight': [
                    { id: 'soldier', name: 'å…µå£«', emoji: 'ğŸ›¡ï¸', hp: 40, atk: 14, range: 1, move: 3, cost: 200 },
                    { id: 'paladin', name: 'é¨å£«', emoji: 'ğŸ‡', hp: 60, atk: 20, range: 1, move: 5, cost: 500 }
                ],
                'mage': [
                    { id: 'elf', name: 'ã‚¨ãƒ«ãƒ•', emoji: 'ğŸ¹', hp: 30, atk: 18, range: 3, move: 3, cost: 300 },
                    { id: 'fairy', name: 'å¦–ç²¾', emoji: 'ğŸ§š', hp: 25, atk: 12, range: 2, move: 4, cost: 250 }
                ],
                'demon': [
                    { id: 'imp', name: 'å°æ‚ªé­”', emoji: 'ğŸ‘¿', hp: 28, atk: 18, range: 1, move: 4, cost: 150 },
                    { id: 'dragon', name: 'ç«œ', emoji: 'ğŸ‰', hp: 95, atk: 32, range: 1, move: 6, cost: 1000 }
                ]
            },

            MAP_TEMPLATES: [
                {
                    id: 'classic', name: 'ãƒãƒãƒ ãƒ¼ãƒˆå¤§é™¸ (Classic)', desc: 'æ¨™æº–çš„ãªãƒãƒ©ãƒ³ã‚¹ã®åˆæœŸãƒãƒƒãƒ—ã§ã™ã€‚',
                    castles: [
                        { id: 'c1', name: 'ç‹éƒ½', x: 150, y: 200, owner: 'player', captureBonus: 0, uniqueUnit: null, neighbors: ['c3', 'c7'] },
                        { id: 'c2', name: 'æš—é»’åŸ', x: 750, y: 550, owner: 'enemy', captureBonus: 2000, uniqueUnit: 'hell-hound', neighbors: ['c3', 'c5', 'c6'] },
                        { id: 'c6', name: 'æ±ã®å¡”', x: 750, y: 150, owner: 'enemy2', captureBonus: 800, uniqueUnit: 'sorcerer', neighbors: ['c2', 'c4'] },
                        { id: 'c3', name: 'è‡ªç”±éƒ½å¸‚', x: 450, y: 350, owner: 'neutral', captureBonus: 500, uniqueUnit: 'guard', neighbors: ['c1', 'c2', 'c4', 'c5'] },
                        { id: 'c4', name: 'åŒ—ã®ç ¦', x: 450, y: 100, owner: 'neutral', captureBonus: 350, uniqueUnit: 'crossbow', neighbors: ['c3', 'c6'] },
                        { id: 'c5', name: 'å—ã®æ‘', x: 250, y: 550, owner: 'neutral', captureBonus: 200, uniqueUnit: 'militia', neighbors: ['c2', 'c3'] },
                        { id: 'c7', name: 'è¥¿ã®å»ƒå¢Ÿ', x: 100, y: 450, owner: 'neutral', captureBonus: 400, uniqueUnit: 'ghost', neighbors: ['c1'] }
                    ]
                },
                {
                    id: 'islands', name: 'ç¾¤å³¶è«¸å›½ (Islands)', desc: 'ç´°é•·ã„ãƒ«ãƒ¼ãƒˆã§æ§‹æˆã•ã‚ŒãŸæ©Ÿå‹•åŠ›ãŒè©¦ã•ã‚Œã‚‹ãƒãƒƒãƒ—ã€‚',
                    castles: [
                        { id: 'c1', name: 'ç‹éƒ½', x: 100, y: 300, owner: 'player', captureBonus: 0, uniqueUnit: null, neighbors: ['c3'] },
                        { id: 'c2', name: 'å½±ã®å³¶', x: 800, y: 300, owner: 'enemy', captureBonus: 2000, uniqueUnit: 'hell-hound', neighbors: ['c6'] },
                        { id: 'c5', name: 'ç‚ã®é‹æ²³', x: 650, y: 450, owner: 'enemy2', captureBonus: 300, uniqueUnit: 'sorcerer', neighbors: ['c4', 'c6'] },
                        { id: 'c3', name: 'é¢¨ã®é–¢æ‰€', x: 250, y: 150, owner: 'neutral', captureBonus: 300, uniqueUnit: 'crossbow', neighbors: ['c1', 'c4'] },
                        { id: 'c4', name: 'ä¸­å¤®å³¶', x: 450, y: 300, owner: 'neutral', captureBonus: 600, uniqueUnit: 'guard', neighbors: ['c3', 'c5'] },
                        { id: 'c6', name: 'å¢ƒç•Œã®é–€', x: 700, y: 150, owner: 'neutral', captureBonus: 400, uniqueUnit: 'pirate', neighbors: ['c2', 'c5'] }
                    ]
                },
                {
                    id: 'ring', name: 'ç’°çŠ¶å¤§é™¸ (Ring)', desc: 'æ‹ ç‚¹ãŒè¼ªã®ã‚ˆã†ã«ç¹‹ãŒã£ãŸç‰¹æ®Šãªãƒãƒƒãƒ—ã€‚',
                    castles: [
                        { id: 'c1', name: 'ç‹éƒ½', x: 450, y: 80, owner: 'player', captureBonus: 0, uniqueUnit: null, neighbors: ['c3', 'c4'] },
                        { id: 'c2', name: 'æš—é»’åŸ', x: 450, y: 520, owner: 'enemy', captureBonus: 2000, uniqueUnit: 'hell-hound', neighbors: ['c5', 'c6'] },
                        { id: 'c3', name: 'æ±ã®æ¸¯', x: 700, y: 200, owner: 'enemy2', captureBonus: 400, uniqueUnit: 'pirate', neighbors: ['c1', 'c5'] },
                        { id: 'c4', name: 'è¥¿ã®ç ¦', x: 200, y: 200, owner: 'neutral', captureBonus: 400, uniqueUnit: 'dwarf', neighbors: ['c1', 'c6'] },
                        { id: 'c5', name: 'å—æ±ã®å¹³åŸ', x: 700, y: 400, owner: 'neutral', captureBonus: 400, uniqueUnit: 'berserker', neighbors: ['c3', 'c2'] },
                        { id: 'c6', name: 'å—è¥¿ã®æ£®', x: 200, y: 400, owner: 'neutral', captureBonus: 400, uniqueUnit: 'fenrir', neighbors: ['c4', 'c2'] }
                    ]
                }
            ],

            SPECIAL_UNITS: {
                'hell-hound': { id: 'hell-hound', name: 'ã‚±ãƒ«ãƒ™ãƒ­ã‚¹', emoji: 'ğŸ•', hp: 45, atk: 22, range: 1, move: 5, cost: 600, origin: 'æš—é»’åŸ' },
                'guard': { id: 'guard', name: 'é‡è£…è¡›å…µ', emoji: 'ğŸ’‚', hp: 80, atk: 18, range: 1, move: 2, cost: 400, origin: 'è‡ªç”±éƒ½å¸‚' },
                'crossbow': { id: 'crossbow', name: 'å¼©å…µ', emoji: 'ğŸ¹', hp: 35, atk: 22, range: 4, move: 2, cost: 550, origin: 'åŒ—ã®ç ¦' },
                'militia': { id: 'militia', name: 'ç¾©å‹‡å…µ', emoji: 'ğŸ§‘â€ğŸŒ¾', hp: 25, atk: 12, range: 1, move: 3, cost: 100, origin: 'å—ã®æ‘' },
                'sorcerer': { id: 'sorcerer', name: 'é­”å°å¸«', emoji: 'ğŸ§™', hp: 40, atk: 28, range: 3, move: 2, cost: 800, origin: 'æ±ã®å¡”' },
                'ghost': { id: 'ghost', name: 'äº¡éœŠ', emoji: 'ğŸ‘»', hp: 25, atk: 22, range: 1, move: 6, cost: 350, origin: 'è¥¿ã®å»ƒå¢Ÿ' },
                'pirate': { id: 'pirate', name: 'æµ·è³Š', emoji: 'ğŸ´â€â˜ ï¸', hp: 50, atk: 24, range: 1, move: 4, cost: 450, origin: 'è«¸å³¶/æ¸¯' },
                'dwarf': { id: 'dwarf', name: 'ãƒ‰ãƒ¯ãƒ¼ãƒ•å…µ', emoji: 'âš’ï¸', hp: 70, atk: 26, range: 1, move: 2, cost: 600, origin: 'è¥¿ã®ç ¦' },
                'berserker': { id: 'berserker', name: 'ç‹‚æˆ¦å£«', emoji: 'ğŸª“', hp: 45, atk: 35, range: 1, move: 4, cost: 700, origin: 'æ±ã®å¹³åŸ' },
                'fenrir': { id: 'fenrir', name: 'é­”ç‹¼', emoji: 'ğŸº', hp: 55, atk: 24, range: 1, move: 6, cost: 650, origin: 'å—è¥¿ã®æ£®' }
            },

            state: {
                currentScreen: 'title',
                selectedMapId: 'classic',
                factions: [], // { id, name, gold, master, color, isPlayer, isAlive, hqId }
                mapUnits: [], castles: [], selectedMapUnit: null,
                strategicTurn: 'player', // faction id
                battleUnitA: null, battleUnitB: null, // Units in tactical battle
                globalBattleCooldown: 0, gameCleared: false, turnCount: 0, aiActionStarted: false,
                battle: { active: false, grid: [], units: [], turn: 'player', selectedUnit: null, movedUnits: new Set(), tempMoved: false }
            },

            getCubeCoords(r, c) {
                const x = c - Math.floor(r / 2); const z = r; const y = -x - z;
                return { x, y, z };
            },

            getHexDist(r1, c1, r2, c2) {
                const a = this.getCubeCoords(r1, c1); const b = this.getCubeCoords(r2, c2);
                return Math.max(Math.abs(a.x - b.x), Math.abs(a.y - b.y), Math.abs(a.z - b.z));
            }
        };

        /**
         * VIEW: è¡¨ç¤ºåˆ¶å¾¡
         */
        const UI = {
            // åŸºæœ¬çš„ãªãƒœã‚¿ãƒ³ã‚¹ã‚¿ã‚¤ãƒ«
            Button: (label, onclick, type = 'primary', extraClass = '') => {
                const base = "px-10 py-4 border-2 transition-all font-bold shadow-xl hover:scale-105 active:translate-y-1 text-white disabled:opacity-50 disabled:cursor-not-allowed";
                const types = {
                    primary: "bg-red-900 hover:bg-red-700 border-white text-3xl",
                    secondary: "bg-blue-900 hover:bg-blue-700 border-white text-2xl",
                    neutral: "bg-gray-900 hover:bg-gray-700 border-gray-500 text-xl",
                    battle: "bg-blue-800 hover:bg-blue-600 border-white text-2xl rounded-lg",
                    action: "bg-purple-900 hover:bg-purple-700 border-purple-400 text-xl",
                    menu: "bg-green-900 hover:bg-green-700 border-white text-lg"
                };
                return `<button onclick="${onclick}" class="${base} ${types[type]} ${extraClass}">${label}</button>`;
            },

            // é¸æŠç”¨ã‚«ãƒ¼ãƒ‰ï¼ˆãƒãƒƒãƒ—ç”¨ãƒ»ãƒã‚¹ã‚¿ãƒ¼ç”¨å…±é€šï¼‰
            Card: (title, desc, icon, onclick, subtext = '', extraClass = '') => {
                return `
                    <div onclick="${onclick}" 
                         class="group p-10 border-4 border-gray-700 hover:border-yellow-500 transition-all cursor-pointer rounded-2xl bg-gray-900/80 shadow-2xl hover:scale-105 flex flex-col items-center w-[400px] shrink-0 ${extraClass}">
                        ${icon ? `<div class="text-9xl mb-8 transition-transform group-hover:scale-110">${icon}</div>` : ''}
                        <div class="text-4xl font-bold mb-4 text-white text-center group-hover:text-yellow-500 transition-colors">${title}</div>
                        <p class="text-xl text-gray-400 text-center leading-relaxed mb-6">${desc}</p>
                        ${subtext ? `<div class="text-yellow-500 font-bold uppercase tracking-widest text-sm animate-pulse">${subtext}</div>` : ''}
                    </div>`;
            },

            // å„ç¨®ãƒ‘ãƒãƒ«
            Panel: (content, extraClass = '') => {
                return `<div class="bg-gray-800/80 border-2 border-gray-700 p-8 rounded-2xl shadow-2xl mb-4 text-white ${extraClass}">${content}</div>`;
            },

            // éƒ¨éšŠã‚«ãƒ¼ãƒ‰ (BaseMenuå†…ãªã©ã§ä½¿ç”¨)
            ArmyCard: (unit, isPlayer, factionName, extraContent = '') => {
                const colorClass = isPlayer ? 'text-blue-300' : 'text-red-400';
                const bgClass = isPlayer ? 'bg-gray-800/80 border-gray-700' : 'bg-red-900/20 border-red-700/50';
                return `
                    <div class="${bgClass} border-2 p-8 rounded-2xl shadow-2xl mb-4 text-white">
                        <div class="flex justify-between items-center mb-8 border-b border-gray-600 pb-4">
                            <div class="flex items-center gap-6">
                                <span class="text-6xl">${unit.emoji}</span>
                                <span class="text-3xl font-bold ${colorClass}">${factionName}</span>
                            </div>
                            <span class="text-xl font-bold font-mono">æ§‹æˆ: ${unit.army.length} / ${Model.MAX_UNITS}</span>
                        </div>
                        ${extraContent}
                    </div>`;
            },

            // ãƒ¦ãƒ‹ãƒƒãƒˆè©³ç´°è¡Œ
            UnitListItem: (u, index, callbacks = null) => {
                const rankName = Model.RANKS[u.rank || 0];
                const xpPercent = u.rank === 5 ? 100 : ((u.xp || 0) / Model.RANK_UP_XP) * 100;
                const hpColor = u.currentHp / u.hp < 0.3 ? 'text-red-500' : 'text-green-400';
                return `
                    <div class="bg-black/40 p-4 border border-white/10 rounded-lg">
                        <div class="flex justify-between items-center mb-4">
                            <div class="flex items-center gap-4">
                                <span class="text-5xl">${u.emoji}</span>
                                <div>
                                    <div class="text-2xl font-bold">${u.name} <span class="text-yellow-500 ml-2 text-xl">RANK ${rankName}</span></div>
                                    <div class="text-sm text-gray-400">ç·´åº¦: ${u.rank === 5 ? 'MAX' : (u.xp || 0) + ' / ' + Model.RANK_UP_XP}</div>
                                </div>
                            </div>
                            <div class="text-right">
                                <div class="${hpColor} font-bold">HP: ${u.currentHp}/${u.hp}</div>
                                <div class="text-red-400 font-bold">ATK: ${u.atk}</div>
                            </div>
                        </div>
                        <div class="w-full h-2 bg-gray-800 rounded-full overflow-hidden mb-4">
                            <div class="h-full bg-yellow-500" style="width:${xpPercent}%"></div>
                        </div>
                        ${callbacks ? `
                            <div class="flex gap-4">
                                <button onclick="${callbacks.hp}" class="flex-1 py-2 bg-green-900/50 border border-green-700 hover:bg-green-700 text-sm font-bold uppercase transition-colors text-white">HP+10(100G)</button>
                                <button onclick="${callbacks.atk}" class="flex-1 py-2 bg-red-900/50 border border-red-700 hover:bg-red-700 text-sm font-bold uppercase transition-colors text-white">ATK+3(150G)</button>
                            </div>
                        ` : ''}
                    </div>`;
            }
        };

        const View = {
            canvas: null, ctx: null,
            Components: UI,

            changeScreen(screenId) {
                document.querySelectorAll('div[id^="screen-"]').forEach(el => el.classList.add('hidden'));
                const target = document.getElementById(`screen-${screenId}`);
                if (target) target.classList.remove('hidden');
                Model.state.currentScreen = screenId;

                const turnIndicator = document.getElementById('turn-indicator');
                const player = Model.state.factions.find(f => f.isPlayer);
                const isPlayerTurn = Model.state.strategicTurn === 'player';

                if (screenId === 'map') {
                    turnIndicator.classList.add('hidden'); // ãƒãƒƒãƒ—å†…ãƒ˜ãƒƒãƒ€ãƒ¼ã§è¡¨ç¤ºã™ã‚‹ãŸã‚éš ã™
                    this.initCanvas();
                    const endBtn = document.getElementById('btn-end-strategic-turn');
                    const saveLoad = document.getElementById('save-load-group');
                    const menu = document.getElementById('base-menu');
                    menu.classList.add('hidden'); // åˆæœŸçŠ¶æ…‹ã§ã¯ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’éš ã™
                    this.clearBaseMenu();

                    if (isPlayerTurn) {
                        endBtn.classList.remove('hidden');
                        saveLoad.classList.remove('hidden');
                    } else {
                        endBtn.classList.add('hidden');
                        saveLoad.classList.add('hidden');
                    }
                } else {
                    turnIndicator.classList.add('hidden');
                }
            },

            toggleSettings() {
                const el = document.getElementById('screen-settings');
                if (el.classList.contains('hidden')) {
                    this.renderSettings();
                    el.classList.remove('hidden');
                } else {
                    el.classList.add('hidden');
                }
            },

            renderSettings() {
                const list = document.getElementById('map-select-list');
                list.innerHTML = Model.MAP_TEMPLATES.map(t => `
                    <div onclick="Controller.setMap('${t.id}')" 
                         class="p-6 border-2 transition-all cursor-pointer rounded-xl ${Model.state.selectedMapId === t.id ? 'border-yellow-500 bg-yellow-900/20' : 'border-gray-700 hover:border-gray-500 bg-black/40'}">
                        <div class="text-2xl font-bold mb-2 ${Model.state.selectedMapId === t.id ? 'text-yellow-500' : 'text-white'}">${t.name}</div>
                        <p class="text-sm text-gray-400">${t.desc}</p>
                    </div>
                `).join('');
            },

            renderMapFlow() {
                const list = document.getElementById('map-flow-list');
                list.innerHTML = Model.MAP_TEMPLATES.map(t =>
                    UI.Card(t.name, t.desc, '', `Controller.selectMapAndNext('${t.id}')`, 'Click to Select')
                ).join('');
            },

            showMessage(text) {
                const box = document.getElementById('message-box');
                const txt = document.getElementById('message-text');
                txt.innerText = text;
                box.style.opacity = '1';
                if (window.msgTimer) clearTimeout(window.msgTimer);
                window.msgTimer = setTimeout(() => { box.style.opacity = '0'; }, 3500);
            },

            openModal(title, body, buttons) {
                const modal = document.getElementById('modal-layer');
                document.getElementById('modal-title').innerText = title;
                document.getElementById('modal-body').innerText = body;
                const footer = document.getElementById('modal-footer');
                footer.innerHTML = '';
                buttons.forEach(btn => {
                    const b = document.createElement('button');
                    b.className = "px-10 py-4 bg-blue-700 hover:bg-blue-600 border-2 border-white text-2xl transition-colors font-bold rounded-lg shadow-lg text-white";
                    b.innerText = btn.label;
                    b.onclick = () => { modal.classList.add('hidden'); btn.action(); };
                    footer.appendChild(b);
                });
                modal.classList.remove('hidden');
            },

            showEnding(isWin) {
                const screen = document.getElementById('screen-ending');
                const title = document.getElementById('ending-title');
                const body = document.getElementById('ending-body');

                if (isWin) {
                    title.innerText = "VICTORY";
                    title.className = "text-8xl font-bold mb-12 text-yellow-500 uppercase tracking-tighter drop-shadow-[0_0_30px_rgba(234,179,8,0.5)]";
                    body.innerText = "æ•µå‹¢åŠ›ã®æ‹ ç‚¹ã‚’ã™ã¹ã¦åˆ¶åœ§ã—ã€ãƒãƒãƒ ãƒ¼ãƒˆå¤§é™¸ã«çœŸã®å¹³å’ŒãŒè¨ªã‚ŒãŸã€‚ã‚ãªãŸã®åã¯ä¼èª¬ã¨ãªã‚Šã€æ°¸ãèªã‚Šç¶™ãŒã‚Œã‚‹ã ã‚ã†ã€‚";
                } else {
                    title.innerText = "DEFEAT";
                    title.className = "text-8xl font-bold mb-12 text-red-600 uppercase tracking-tighter drop-shadow-[0_0_30px_rgba(220,38,38,0.5)]";
                    body.innerText = "å…¨ã¦ã®æ‹ ç‚¹ã‚’å¤±ã„ã€é‡æœ›ã¯æ½°ãˆãŸã€‚å¤§é™¸ã®æ­´å²ã¯å‹è€…ã«ã‚ˆã£ã¦æ›¸ãæ›ãˆã‚‰ã‚Œã€ã‚ãªãŸã®åã¯é—‡ã¸ã¨æ¶ˆãˆã¦ã„ã£ãŸ...";
                }

                this.changeScreen('ending');
            },

            initCanvas() {
                const canvas = document.getElementById('map-canvas');
                if (!canvas) return;
                const container = canvas.parentElement;
                const newCanvas = canvas.cloneNode(true);
                canvas.parentNode.replaceChild(newCanvas, canvas);
                newCanvas.width = container.clientWidth;
                newCanvas.height = container.clientHeight;
                this.ctx = newCanvas.getContext('2d');
                this.canvas = newCanvas;

                // ãƒãƒƒãƒ—ã®ã‚»ãƒ³ã‚¿ãƒªãƒ³ã‚°è¨ˆç®—
                if (Model.state.castles.length > 0) {
                    const padding = 100;
                    const minX = Math.min(...Model.state.castles.map(c => c.x));
                    const maxX = Math.max(...Model.state.castles.map(c => c.x));
                    const minY = Math.min(...Model.state.castles.map(c => c.y));
                    const maxY = Math.max(...Model.state.castles.map(c => c.y));

                    const mapWidth = maxX - minX;
                    const mapHeight = maxY - minY;
                    const centerX = minX + mapWidth / 2;
                    const centerY = minY + mapHeight / 2;

                    this.mapOffsetX = (this.canvas.width / 2) - centerX;
                    this.mapOffsetY = (this.canvas.height / 2) - centerY;
                } else {
                    this.mapOffsetX = 0;
                    this.mapOffsetY = 0;
                }

                newCanvas.addEventListener('mousedown', Controller.handleMapClick);
                newCanvas.addEventListener('contextmenu', Controller.handleMapRightClick);
                requestAnimationFrame(() => this.renderMapLoop());
            },

            renderMapLoop() {
                if (Model.state.currentScreen !== 'map' || !this.ctx) return;
                const ctx = this.ctx;
                ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                const playerFaction = Model.state.factions.find(f => f.isPlayer);
                if (!playerFaction) return;

                document.getElementById('castle-count-display').innerText = `${Model.state.castles.filter(c => c.owner === playerFaction.id).length} / ${Model.state.castles.length}`;
                document.getElementById('army-total-display').innerText = `${Model.state.mapUnits.filter(u => u.owner === playerFaction.id).length} / ${Model.MAX_ARMIES}`;
                document.getElementById('gold-amount').innerText = Math.floor(playerFaction.gold) + 'G';
                document.getElementById('turn-display').innerText = `SYSTEM TURN ${Model.state.turnCount}`;

                const turnText = document.getElementById('turn-text-map');
                const currentFaction = Model.state.factions.find(f => f.id === Model.state.strategicTurn);
                if (currentFaction && turnText) {
                    turnText.innerText = currentFaction.isPlayer ? "è‡ªè»ãƒ•ã‚§ãƒ¼ã‚º" : `${currentFaction.name}ãƒ•ã‚§ãƒ¼ã‚º`;
                    turnText.style.color = currentFaction.color;
                }

                ctx.setLineDash([10, 5]); ctx.strokeStyle = 'rgba(255,255,255,0.1)'; ctx.lineWidth = 4;
                const ox = this.mapOffsetX || 0;
                const oy = this.mapOffsetY || 0;

                Model.state.castles.forEach(c => {
                    c.neighbors.forEach(nId => {
                        const n = Model.state.castles.find(nc => nc.id === nId);
                        if (n) { ctx.beginPath(); ctx.moveTo(c.x + ox, c.y + oy); ctx.lineTo(n.x + ox, n.y + oy); ctx.stroke(); }
                    });
                });
                ctx.setLineDash([]);

                Model.state.castles.forEach(c => {
                    const cx = c.x + ox;
                    const cy = c.y + oy;

                    ctx.font = '50px serif'; ctx.textAlign = 'center'; ctx.fillText('ğŸ°', cx, cy);
                    ctx.font = '24px DotGothic16';
                    const faction = Model.state.factions.find(f => f.id === c.owner);
                    ctx.fillStyle = faction ? faction.color : '#aaaaaa';
                    ctx.fillText(c.name, cx, cy + 40);

                    ctx.font = '16px DotGothic16';
                    const ownerName = faction ? faction.master.name : 'ä¸­ç«‹';
                    ctx.fillText(ownerName, cx, cy + 65);

                    // HQåˆ¤å®š
                    const isHQ = Model.state.factions.some(f => f.hqId === c.id && f.isAlive);
                    if (isHQ) {
                        ctx.font = 'bold 24px DotGothic16';
                        ctx.fillStyle = '#FFD700'; // Gold
                        ctx.shadowBlur = 10; ctx.shadowColor = 'rgba(255,215,0,0.5)';
                        ctx.fillText('ğŸ‘‘HQ', cx, cy - 60);
                        ctx.shadowBlur = 0;
                    }

                    // æˆ¦åŠ›è¡¨ç¤º
                    const unitsAtCastle = Model.state.mapUnits.filter(u => u.owner === c.owner && Math.hypot(u.x - c.x, u.y - c.y) < 45);
                    const totalAtk = unitsAtCastle.reduce((sum, u) => sum + u.army.reduce((aSum, unit) => aSum + unit.atk, 0), 0);
                    const totalHp = unitsAtCastle.reduce((sum, u) => sum + u.army.reduce((aSum, unit) => aSum + unit.currentHp, 0), 0);
                    if (totalAtk > 0 || totalHp > 0) {
                        ctx.font = 'bold 16px DotGothic16';
                        ctx.fillStyle = '#ffffff';
                        ctx.shadowBlur = 4; ctx.shadowColor = 'black';
                        ctx.fillText(`âš’${totalAtk} â¤${totalHp}`, cx, cy - 45);
                        ctx.shadowBlur = 0;
                    }
                });

                // æç”»é †åºã‚’åˆ¶å¾¡ï¼šéé¸æŠâ†’é¸æŠä¸­ã®é †ã§æç”»ã™ã‚‹ã“ã¨ã§ã€é¸æŠãƒ¦ãƒ‹ãƒƒãƒˆã‚’æœ€å‰é¢ã«è¡¨ç¤º
                const unitsToRender = Model.state.mapUnits.filter(u => {
                    const isStationed = Model.state.castles.some(c => Math.hypot(u.x - c.x, u.y - c.y) < 30) && !u.isMoving;
                    return !(isStationed && u !== Model.state.selectedMapUnit);
                }).sort((a, b) => (a === Model.state.selectedMapUnit ? 1 : (b === Model.state.selectedMapUnit ? -1 : 0)));

                unitsToRender.forEach(u => {
                    const ux = u.x + ox;
                    const uy = u.y + oy;
                    const isSelected = (u === Model.state.selectedMapUnit);

                    if (isSelected) {
                        ctx.save();
                        // é¸æŠãƒãƒ¼ã‚«ãƒ¼ã¨ãƒ†ã‚­ã‚¹ãƒˆ
                        ctx.fillStyle = 'cyan';
                        ctx.font = 'bold 24px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.shadowBlur = 10; ctx.shadowColor = 'black';

                        // ãƒãƒ¼ã‚«ãƒ¼ãŒä¸Šä¸‹ã«ãƒ•ãƒ¯ãƒ•ãƒ¯ã™ã‚‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                        const bounce = Math.sin(Date.now() / 150) * 5;
                        ctx.fillText('â–¼', ux, uy - 45 + bounce);

                        // éƒ¨éšŠè­˜åˆ¥ãƒ†ã‚­ã‚¹ãƒˆ
                        ctx.font = 'bold 16px DotGothic16';
                        const label = u.isMaster ? "â˜…ä¸»è»" : `éƒ¨éšŠ ${Model.state.mapUnits.filter(mu => mu.owner === u.owner).indexOf(u) + 1}`;
                        ctx.fillStyle = '#ffffff';
                        ctx.fillText(label, ux, uy - 70 + bounce);
                        ctx.restore();

                        ctx.shadowBlur = 40; ctx.shadowColor = 'cyan';
                    }

                    ctx.font = '40px serif';
                    ctx.textAlign = 'center';
                    ctx.globalAlpha = (u.owner === 'player' && u.hasActed) ? 0.4 : 1.0;
                    ctx.fillText(u.emoji, ux, uy);
                    ctx.globalAlpha = 1.0; ctx.shadowBlur = 0;
                });

                requestAnimationFrame(() => this.renderMapLoop());
            },

            toggleBaseMenu(castle = null) {
                if (castle) {
                    this.renderBaseMenu(castle);
                    document.getElementById('base-menu').classList.remove('hidden');
                }
            },

            clearBaseMenu() {
                document.getElementById('base-menu').classList.add('hidden');
                document.getElementById('base-menu-title').innerText = "æ‹ ç‚¹ã‚’é¸æŠã—ã¦ãã ã•ã„";
                document.getElementById('base-menu-content').innerHTML = "";
                document.getElementById('no-unit-message').classList.remove('hidden');
            },

            renderBaseMenu(castle, targetUnitId = null) {
                const castleOwner = Model.state.factions.find(f => f.id === castle.owner);
                const playerFaction = Model.state.factions.find(f => f.isPlayer);

                // 1. éƒ¨éšŠæƒ…å ±ã®å–å¾—ã¨ã‚¢ã‚¯ãƒ†ã‚£ãƒ–éƒ¨éšŠã®æ±ºå®š
                const allUnits = Model.state.mapUnits.filter(u => Math.hypot(u.x - castle.x, u.y - castle.y) < 45);
                let activeUnit = null;
                if (allUnits.length > 0) {
                    activeUnit = allUnits.find(u => u.id === targetUnitId);
                    if (!activeUnit) {
                        if (Model.state.selectedMapUnit && allUnits.includes(Model.state.selectedMapUnit)) {
                            activeUnit = Model.state.selectedMapUnit;
                        } else {
                            activeUnit = allUnits.find(u => u.owner === playerFaction.id) || allUnits[0];
                        }
                    }
                }

                // 2. ã‚¿ã‚¤ãƒˆãƒ«è¨­å®šï¼ˆæ‹ ç‚¹å + HQ + ã‚¢ã‚¯ãƒ†ã‚£ãƒ–éƒ¨éšŠæƒ…å ±ï¼‰
                const isHQ = Model.state.factions.some(f => f.hqId === castle.id && f.isAlive);
                let titleHTML = castle.name + (isHQ ? ' <span class="bg-yellow-600 text-white text-sm px-3 py-1 rounded-full align-middle ml-4 border border-yellow-400 font-bold shadow-lg">ğŸ‘‘æœ¬æ‹ åœ°</span>' : '');

                const faction = Model.state.factions.find(f => f.id === castle.owner);
                const color = faction ? faction.color : '#fff';
                const ownerName = faction ? faction.master.name : 'ä¸­ç«‹';
                const ownerEmoji = faction ? faction.master.emoji : '';

                titleHTML += `
                        <span class="ml-6 inline-flex items-center gap-3 align-middle bg-gray-900/50 px-4 py-1 rounded-lg border border-gray-600 shadow-inner">
                    <span class="text-3xl">${ownerEmoji}</span>
                            <span class="text-lg font-bold" style="color:${color}">${ownerName}</span>
                        </span>
                    `;

                document.getElementById('base-menu-title').innerHTML = titleHTML;

                const createBtn = document.getElementById('btn-create-army');
                createBtn.disabled = castle.owner !== playerFaction.id || playerFaction.gold < Model.ARMY_COST || Model.state.mapUnits.filter(u => u.owner === playerFaction.id).length >= Model.MAX_ARMIES;
                createBtn.onclick = () => Controller.createNewArmy(castle);

                const menuContent = document.getElementById('base-menu-content');
                const noMsg = document.getElementById('no-unit-message');
                menuContent.innerHTML = '';

                if (allUnits.length === 0) {
                    noMsg.classList.remove('hidden');
                    noMsg.innerText = "é§ç•™éƒ¨éšŠãªã—";
                    return;
                }
                noMsg.classList.add('hidden');

                // 1. éƒ¨éšŠé¸æŠã‚¿ãƒ–
                const tabContainer = document.createElement('div');
                tabContainer.className = "flex gap-3 overflow-x-auto pb-2 mb-2 custom-scrollbar";

                allUnits.forEach(u => {
                    const isActive = (u === activeUnit);
                    const isPlayerUnit = (u.owner === playerFaction.id);
                    const faction = Model.state.factions.find(f => f.id === u.owner);
                    const color = faction ? faction.color : '#aaaaaa';
                    const count = u.army.length;
                    const max = Model.MAX_UNITS;

                    const btn = document.createElement('button');
                    // ã‚¹ã‚¿ã‚¤ãƒ«èª¿æ•´: ã‚¢ã‚¯ãƒ†ã‚£ãƒ–æ™‚ã¯æ˜ã‚‹ãå¼·èª¿
                    btn.className = `flex-shrink-0 w-20 h-24 border-2 rounded-xl flex flex-col items-center justify-center transition-all shadow-lg relative ${isActive ? 'bg-gray-700/80 border-white scale-105 z-10' : 'bg-gray-900/60 border-gray-700 hover:bg-gray-800 opacity-70'}`;
                    btn.innerHTML = `
                        <div class="text-3xl mb-1">${u.emoji}</div>
                        <div class="text-[10px] font-bold uppercase truncate w-full text-center px-1 mb-1" style="color:${color}">${u.isMaster ? 'ä¸»è»' : 'éƒ¨éšŠ'}</div>
                        <div class="text-[10px] font-mono font-bold ${count >= max ? 'text-red-400' : 'text-cyan-400'}">${count}/${max}</div>
                        ${isActive ? '<div class="absolute -bottom-2 text-yellow-500 text-xs">â–²</div>' : ''}
                    `;
                    btn.onclick = () => {
                        // è‡ªè»éƒ¨éšŠãªã‚‰é¸æŠçŠ¶æ…‹ã‚‚æ›´æ–°
                        if (isPlayerUnit) {
                            Model.state.selectedMapUnit = u;
                        }
                        this.renderBaseMenu(castle, u.id);
                    };
                    tabContainer.appendChild(btn);
                });
                menuContent.appendChild(tabContainer);

                // 2. è©³ç´°è¡¨ç¤º (activeUnitã®å†…å®¹)
                if (activeUnit) {
                    const isPlayerUnit = (activeUnit.owner === playerFaction.id);
                    const faction = Model.state.factions.find(f => f.id === activeUnit.owner);

                    let contentHTML = '';

                    if (isPlayerUnit) {
                        // è‡ªè»: é›‡ç”¨ãƒ‘ãƒãƒ« + éƒ¨éšŠãƒªã‚¹ãƒˆ
                        const factionUnits = Model.FACTION_UNITS[playerFaction.master.id];
                        let options = [...factionUnits];
                        if (castle.uniqueUnit) {
                            const spec = Model.SPECIAL_UNITS[castle.uniqueUnit];
                            if (spec) options.push(spec);
                        }

                        const recruitHTML = `
                            <div class="bg-black/40 p-4 rounded-xl border border-blue-900/30 mb-6">
                                <p class="text-xl text-blue-400 mb-4 font-bold border-b border-blue-900/50 pb-2 uppercase tracking-widest text-center">ãƒ¦ãƒ‹ãƒƒãƒˆé›‡ç”¨</p>
                                <div class="grid grid-cols-1 gap-2 max-h-60 overflow-y-auto custom-scrollbar p-1">${options.map(ut => this.recruitItemHTML(ut, activeUnit, castle)).join('')}</div>
                            </div>`;

                        const unitsHTML = `
                            <p class="text-sm text-gray-400 mb-2 font-bold uppercase tracking-widest text-center">éƒ¨éšŠç·¨æˆãƒ»å¼·åŒ–</p>
                            <div class="flex flex-col gap-3">
                                ${activeUnit.army.map((u, i) => UI.UnitListItem(u, i, {
                            hp: `Controller.enhanceUnit('${activeUnit.id}', ${i}, 'hp', '${castle.id}')`,
                            atk: `Controller.enhanceUnit('${activeUnit.id}', ${i}, 'atk', '${castle.id}')`
                        })).join('')}
                            </div>`;

                        contentHTML = recruitHTML + unitsHTML;
                    } else {
                        // æ•µè»: éƒ¨éšŠãƒªã‚¹ãƒˆã®ã¿
                        contentHTML = `<div class="flex flex-col gap-3">${activeUnit.army.map((u, i) => UI.UnitListItem(u, i)).join('')}</div>`;
                    }

                    // ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®ã¿è¿½åŠ  (ã‚«ãƒ¼ãƒ‰ãƒ˜ãƒƒãƒ€ãƒ¼ãªã—)
                    const contentWrapper = document.createElement('div');
                    contentWrapper.innerHTML = contentHTML;
                    menuContent.appendChild(contentWrapper);
                }
            },

            recruitItemHTML(ut, unit, castle) {
                const playerFaction = Model.state.factions.find(f => f.isPlayer);
                const can = playerFaction.gold >= ut.cost;
                const isFull = unit.army.length >= Model.MAX_UNITS;
                const dis = isFull || !can || castle.owner !== playerFaction.id;
                const lbl = isFull ? "æº€å“¡" : `${ut.cost}G`;
                return `<div class="recruit-item flex justify-between items-center bg-white/5 p-4 rounded-xl border border-white/10 cursor-pointer transition-colors" 
                    onclick="View.showMessage('ã€${ut.name}ã€‘ HP:${ut.hp} / ATK:${ut.atk} / RNG:${ut.range} / MOVE:${ut.move}')">
                    <div class="flex items-center gap-6">
                        <span class="text-6xl">${ut.emoji}</span>
                        <div>
                            <div class="text-3xl font-bold text-white">${ut.name}</div>
                            <div class="text-sm text-blue-400 font-bold uppercase font-mono">ã‚¹ãƒšãƒƒã‚¯ã‚’è¡¨ç¤º (Click)</div>
                        </div>
                    </div>
                    <button onclick="event.stopPropagation(); Controller.recruitUnit('${unit.id}', '${ut.id}', '${castle.id}')" 
                        class="px-10 py-4 bg-blue-900 border-2 border-blue-400 hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed text-2xl font-bold shadow-2xl active:translate-y-1 text-white" 
                        ${dis ? 'disabled' : ''}>${lbl}</button>
                </div>`;
            },

            updateBattleUI() {
                const b = Model.state.battle;
                b.grid.forEach(cell => { cell.el.innerHTML = ''; cell.el.classList.remove('bg-blue-900/40', 'bg-red-900/40', 'ring-4', 'ring-white'); });
                b.units.forEach(u => {
                    const cell = b.grid.find(g => g.r === u.r && g.c === u.c);
                    if (cell) {
                        const div = document.createElement('div'); div.className = "relative flex flex-col items-center justify-center pointer-events-none w-full h-full";
                        div.innerHTML = `
                            <div class="flex items-center gap-1 mb-1">
                                <span class="text-4xl shadow-black drop-shadow-md">${u.emoji}</span>
                                <span class="text-[10px] text-yellow-500 font-bold bg-black/50 px-1 rounded">${Model.RANKS[u.rank || 0]}</span>
                            </div>
                            <div class="w-12 h-1.5 bg-gray-900 border border-gray-600 rounded-full overflow-hidden shadow-sm">
                                <div class="h-full bg-gradient-to-r from-green-600 to-green-400 transition-all duration-300" style="width:${Math.max(0, (u.currentHp / u.hp) * 100)}%"></div>
                            </div>`;
                        if (b.movedUnits.has(u)) div.style.opacity = "0.4";
                        cell.el.appendChild(div);
                    }
                });
                if (b.selectedUnit) {
                    const s = b.selectedUnit;
                    const sc = b.grid.find(g => g.r === s.r && g.c === s.c);
                    if (sc) sc.el.classList.add('ring-4', 'ring-white');
                    b.grid.forEach(cell => {
                        const d = Model.getHexDist(s.r, s.c, cell.r, cell.c);
                        if (!b.tempMoved && d > 0 && d <= s.move && !b.units.some(u => u.r === cell.r && u.c === cell.c)) cell.el.classList.add('bg-blue-900/40');
                        if (!(s.range > 1 && b.tempMoved) && d > 0 && d <= s.range) cell.el.classList.add('bg-red-900/40');
                    });
                }
                const btn = document.getElementById('battle-end-turn-btn');
                if (btn) btn.disabled = (b.turn !== 'player');
            }
        };

        /**
         * CONTROLLER: åˆ¶å¾¡ãƒ­ã‚¸ãƒƒã‚¯
         */
        const Controller = {
            init() { setInterval(() => this.updateLogic(), 50); },

            startFlow() {
                View.changeScreen('map-select');
                View.renderMapFlow();
            },

            selectMapAndNext(id) {
                Model.state.selectedMapId = id;
                this.showMasterSelection();
            },

            showMasterSelection() {
                View.changeScreen('select');
                const container = document.querySelector('#screen-select div');
                container.innerHTML = Model.MASTERS.map(m =>
                    View.Components.Card(m.name, m.desc, m.emoji, `Controller.selectMaster('${m.id}')`, 'ã“ã®ãƒã‚¹ã‚¿ãƒ¼ã§é–‹å§‹', `border-[${m.color}]`)
                ).join('');
            },

            selectMaster(id) {
                const playerMaster = Model.MASTERS.find(m => m.id === id);
                const others = Model.MASTERS.filter(m => m.id !== id);

                // å‹¢åŠ›ã®åˆæœŸåŒ–
                Model.state.factions = [
                    { id: 'player', name: 'è‡ªè»', gold: 500, master: playerMaster, color: '#44aaff', isPlayer: true, isAlive: true, hqId: 'c1' },
                    { id: 'enemy', name: 'æ•µè»', gold: 500, master: others[0], color: '#ff4444', isPlayer: false, isAlive: true, hqId: 'c2' },
                    { id: 'enemy2', name: 'ç¬¬äºŒæ•µè»', gold: 500, master: others[1], color: '#ff44ff', isPlayer: false, isAlive: true, hqId: (Model.state.selectedMapId === 'classic' ? 'c6' : (Model.state.selectedMapId === 'islands' ? 'c5' : 'c3')) }
                ];

                document.getElementById('master-name').innerText = playerMaster.name;
                document.getElementById('master-name').style.color = playerMaster.color;
                document.getElementById('master-alignment').innerText = playerMaster.alignment;

                // é¸æŠã•ã‚ŒãŸãƒãƒƒãƒ—ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‹ã‚‰ã‚³ãƒ”ãƒ¼ã—ã¦åˆæœŸåŒ–
                const template = Model.MAP_TEMPLATES.find(t => t.id === Model.state.selectedMapId) || Model.MAP_TEMPLATES[0];
                Model.state.castles = JSON.parse(JSON.stringify(template.castles));

                Model.state.mapUnits = Model.state.factions.map(f => {
                    const hq = Model.state.castles.find(c => c.id === f.hqId);
                    return {
                        id: f.id + '-master', owner: f.id, x: hq.x, y: hq.y, targetX: hq.x, targetY: hq.y,
                        emoji: f.master.emoji,
                        army: Model.FACTION_UNITS[f.master.id].map(u => ({ ...u, currentHp: u.hp, rank: 0, xp: 0 })),
                        isMaster: f.isPlayer, hasActed: false, isMoving: false
                    };
                });

                View.changeScreen('map');
            },

            setMap(id) {
                Model.state.selectedMapId = id;
                View.renderSettings();
            },

            updateLogic() {
                if (Model.state.currentScreen !== 'map') return;

                Model.state.mapUnits.forEach(u => {
                    const dx = u.targetX - u.x, dy = u.targetY - u.y, dist = Math.hypot(dx, dy);
                    if (dist > Model.UNIT_SPEED) { u.x += dx / dist * Model.UNIT_SPEED; u.y += dy / dist * Model.UNIT_SPEED; }
                    else { u.x = u.targetX; u.y = u.targetY; u.isMoving = false; }
                });

                if (Model.state.globalBattleCooldown > 0) Model.state.globalBattleCooldown--;
                if (Model.state.globalBattleCooldown <= 0 && !Model.state.gameCleared) {
                    for (let i = 0; i < Model.state.mapUnits.length; i++) {
                        for (let j = i + 1; j < Model.state.mapUnits.length; j++) {
                            const u1 = Model.state.mapUnits[i], u2 = Model.state.mapUnits[j];
                            if (u1.owner !== u2.owner && Math.hypot(u1.x - u2.x, u1.y - u2.y) < 30) {
                                u1.isMoving = false; u2.isMoving = false;

                                const playerFaction = Model.state.factions.find(f => f.isPlayer);
                                if (u1.owner === playerFaction.id || u2.owner === playerFaction.id) {
                                    Model.state.battleUnitA = (u1.owner === playerFaction.id) ? u1 : u2;
                                    Model.state.battleUnitB = (u1.owner === playerFaction.id) ? u2 : u1;
                                    this.startBattle();
                                } else {
                                    // AI vs AI: ã‚ªãƒ¼ãƒˆãƒãƒˆãƒ«å‡¦ç†
                                    this.autoResolveBattle(u1, u2);
                                }
                                return;
                            }
                        }
                    }
                }

                Model.state.castles.forEach(c => {
                    const unitsOnCastle = Model.state.mapUnits.filter(u => Math.hypot(u.x - c.x, u.y - c.y) < 40);
                    const playerFaction = Model.state.factions.find(f => f.isPlayer);
                    const currentGuard = unitsOnCastle.find(u => u.owner === c.owner);

                    if (!currentGuard) {
                        const playerUnit = unitsOnCastle.find(u => u.owner === playerFaction.id && !u.isMoving);
                        const enemyUnit = unitsOnCastle.find(u => u.owner !== playerFaction.id && !u.isMoving); // Any non-player unit

                        if (playerUnit && !enemyUnit && c.owner !== playerFaction.id) {
                            playerFaction.gold += c.captureBonus;
                            c.captureBonus = 0; // ãƒœãƒ¼ãƒŠã‚¹å–å¾—æ¸ˆã¿
                            c.owner = playerFaction.id; View.showMessage(`${c.name}åˆ¶åœ§ï¼`);

                            // æ•µæœ¬æ‹ åœ°é™¥è½ã«ã‚ˆã‚‹é™ä¼
                            const capturedFaction = Model.state.factions.find(f => f.hqId === c.id);
                            if (capturedFaction && !capturedFaction.isPlayer && capturedFaction.isAlive) {
                                View.showMessage(`${capturedFaction.name}ãŒé™¥è½ï¼ æ•µè»ã¯é™ä¼ã—ã¾ã—ãŸã€‚`);
                                capturedFaction.isAlive = false;
                                Model.state.mapUnits = Model.state.mapUnits.filter(u => u.owner !== capturedFaction.id);
                                Model.state.castles.forEach(cas => { if (cas.owner === capturedFaction.id) cas.owner = playerFaction.id; });
                            }

                            this.checkWinCondition();
                        } else if (enemyUnit && !playerUnit && c.owner !== enemyUnit.owner) {
                            const captorFaction = Model.state.factions.find(f => f.id === enemyUnit.owner);
                            const previousOwnerId = c.owner;

                            if (captorFaction) captorFaction.gold += c.captureBonus;
                            c.captureBonus = 0;
                            c.owner = captorFaction.id;

                            // æœ¬æ‹ åœ°é™¥è½åˆ¤å®š
                            const defeatedFaction = Model.state.factions.find(f => f.id === previousOwnerId && f.hqId === c.id);
                            if (defeatedFaction && !defeatedFaction.isPlayer) {
                                View.showMessage(`${defeatedFaction.name}ãŒé™¥è½ï¼ å‹åˆ©ã—ãŸ${captorFaction.name}ãŒå…¨ã¦ã®é ˜åœ°ã‚’å¸åã—ã¾ã—ãŸã€‚`);
                                defeatedFaction.isAlive = false;
                                Model.state.mapUnits = Model.state.mapUnits.filter(u => u.owner !== defeatedFaction.id);
                                Model.state.castles.forEach(cas => { if (cas.owner === defeatedFaction.id) cas.owner = captorFaction.id; });
                            }

                            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æœ¬æ‹ åœ°ï¼ˆç‹éƒ½ï¼‰é™¥è½ã«ã‚ˆã‚‹æ•—åŒ—
                            if (c.id === playerFaction.hqId && c.owner !== playerFaction.id) {
                                Model.state.gameCleared = true;
                                View.showEnding(false);
                                return;
                            }

                            this.checkWinCondition();
                        }
                    }
                });

                // ã‚¿ãƒ¼ãƒ³é·ç§»ã®ãƒã‚§ãƒƒã‚¯
                if (Model.state.strategicTurn !== 'player' && Model.state.aiActionStarted) {
                    const anyMoving = Model.state.mapUnits.some(u => u.isMoving);
                    const battleActive = Model.state.currentScreen === 'battle';
                    const encounterWaiting = Model.state.globalBattleCooldown > 0;

                    if (!anyMoving && !battleActive && !encounterWaiting) {
                        this.startNextFactionTurn();
                    }
                }
            },

            checkWinCondition() {
                if (Model.state.gameCleared) return;
                const playerFaction = Model.state.factions.find(f => f.isPlayer);
                const pOwned = Model.state.castles.filter(c => c.owner === playerFaction.id).length;
                const activeEnemyFactions = Model.state.factions.filter(f => !f.isPlayer && f.isAlive);

                if (activeEnemyFactions.length === 0) {
                    Model.state.gameCleared = true;
                    setTimeout(() => View.showEnding(true), 1500); // é™ä¼æ¼”å‡ºã‚’è¦‹ã›ã‚‹ãŸã‚å°‘ã—å¾…ã¤
                } else if (pOwned === 0) {
                    Model.state.gameCleared = true;
                    View.showEnding(false);
                }
            },

            handleMapClick(e) {
                if (e.button !== 0 || Model.state.strategicTurn !== 'player' || Model.state.gameCleared) return;
                const rect = View.canvas.getBoundingClientRect();
                const ox = View.mapOffsetX || 0;
                const oy = View.mapOffsetY || 0;
                const x = e.clientX - rect.left - ox; // ã‚ªãƒ•ã‚»ãƒƒãƒˆè£œæ­£
                const y = e.clientY - rect.top - oy; // ã‚ªãƒ•ã‚»ãƒƒãƒˆè£œæ­£

                // 1. ã™ã§ã«éƒ¨éšŠãŒé¸æŠã•ã‚Œã¦ã„ã‚‹å ´åˆã€ã¾ãšç§»å‹•å…ˆï¼ˆæ‹ ç‚¹ï¼‰ãŒã‚¯ãƒªãƒƒã‚¯ã•ã‚ŒãŸã‹ã‚’ç¢ºèª
                if (Model.state.selectedMapUnit) {
                    const castle = Model.state.castles.find(c => Math.hypot(c.x - x, c.y - y) < 45);
                    if (castle) {
                        const current = Model.state.castles.find(c => Math.hypot(c.x - Model.state.selectedMapUnit.x, c.y - Model.state.selectedMapUnit.y) < 45);
                        if (current && current.neighbors.includes(castle.id)) {
                            Model.state.selectedMapUnit.targetX = castle.x; Model.state.selectedMapUnit.targetY = castle.y;
                            Model.state.selectedMapUnit.isMoving = true; Model.state.selectedMapUnit.hasActed = true;
                            // ç§»å‹•å¾Œã¯é¸æŠè§£é™¤ã€‚ãƒ‘ãƒãƒ«æ“ä½œã¯ã—ãªã„ï¼ˆå³ã‚¯ãƒªãƒƒã‚¯ã«ä»»ã›ã‚‹ï¼‰
                            Model.state.selectedMapUnit = null;
                            View.clearBaseMenu();
                            return;
                        }
                        // éš£æ¥ã—ã¦ã„ãªã„å ´åˆã¯ä¸‹ã®é¸æŠå‡¦ç†ã¸æµã™ï¼ˆç§»å‹•ã‚­ãƒ£ãƒ³ã‚»ãƒ«ï¼†åˆ¥ãƒ¦ãƒ‹ãƒƒãƒˆé¸æŠã®å¯èƒ½æ€§ï¼‰
                    }
                }

                // 2. éƒ¨éšŠã®é¸æŠãƒ»åˆ‡ã‚Šæ›¿ãˆï¼ˆãƒ‘ãƒãƒ«è¡¨ç¤ºãªã—ï¼‰
                const playerFaction = Model.state.factions.find(f => f.isPlayer);
                const clickedUnits = Model.state.mapUnits.filter(u => u.owner === playerFaction.id && !u.hasActed && Math.hypot(u.x - x, u.y - y) < 45);

                if (clickedUnits.length > 0) {
                    // éƒ¨éšŠãŒã„ã‚Œã°ãã‚Œã‚’é¸æŠ
                    let nextIdx = 0;
                    if (Model.state.selectedMapUnit && clickedUnits.includes(Model.state.selectedMapUnit)) {
                        nextIdx = (clickedUnits.indexOf(Model.state.selectedMapUnit) + 1) % clickedUnits.length;
                    }
                    Model.state.selectedMapUnit = clickedUnits[nextIdx];
                    // ãƒ‘ãƒãƒ«ã¯è¡¨ç¤ºã—ãªã„
                } else {
                    // ä½•ã‚‚ãªã„å ´æ‰€ã€ã‚ã‚‹ã„ã¯ãƒ¦ãƒ‹ãƒƒãƒˆã®ã„ãªã„æ‹ ç‚¹ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸã‚‰é¸æŠè§£é™¤
                    Model.state.selectedMapUnit = null;
                    View.clearBaseMenu();
                }
            },

            handleMapRightClick(e) {
                e.preventDefault();
                const rect = View.canvas.getBoundingClientRect();
                const ox = View.mapOffsetX || 0;
                const oy = View.mapOffsetY || 0;
                const x = e.clientX - rect.left - ox; // ã‚ªãƒ•ã‚»ãƒƒãƒˆè£œæ­£
                const y = e.clientY - rect.top - oy; // ã‚ªãƒ•ã‚»ãƒƒãƒˆè£œæ­£

                // æ‹ ç‚¹ãŒã‚ã‚Œã°æƒ…å ±è¡¨ç¤º
                const clickedCastle = Model.state.castles.find(c => Math.hypot(c.x - x, c.y - y) < 45);

                if (clickedCastle) {
                    View.toggleBaseMenu(clickedCastle);
                } else {
                    // ä½•ã‚‚ãªã„å ´æ‰€ãªã‚‰é¸æŠè§£é™¤ï¼†ãƒ¡ãƒ‹ãƒ¥ãƒ¼é–‰ã˜
                    Model.state.selectedMapUnit = null;
                    View.clearBaseMenu();
                }
            },

            endStrategicTurn() {
                if (Model.state.strategicTurn !== 'player') return;

                const movingUnit = Model.state.mapUnits.find(u => u.owner === 'player' && u.isMoving);
                if (movingUnit) { View.showMessage("éƒ¨éšŠãŒç§»å‹•ä¸­ã§ã™ã€‚å®Œäº†ã¾ã§ãŠå¾…ã¡ãã ã•ã„ã€‚"); return; }

                this.startNextFactionTurn();
            },

            startNextFactionTurn() {
                const currentFactionIdx = Model.state.factions.findIndex(f => f.id === Model.state.strategicTurn);
                let nextFaction = null;
                for (let i = 1; i <= Model.state.factions.length; i++) { // Iterate through all factions, including current
                    const f = Model.state.factions[(currentFactionIdx + i) % Model.state.factions.length];
                    if (f.isAlive) {
                        nextFaction = f;
                        break;
                    }
                }

                if (!nextFaction) { // No active factions left (shouldn't happen if player is alive)
                    this.checkWinCondition();
                    return;
                }

                if (nextFaction.isPlayer) {
                    this.startPlayerTurn();
                } else {
                    this.startEnemyTurn(nextFaction.id);
                }
            },

            startEnemyTurn(factionId) {
                Model.state.strategicTurn = factionId;
                Model.state.aiActionStarted = false;

                const faction = Model.state.factions.find(f => f.id === factionId);
                if (!faction || !faction.isAlive) {
                    this.startNextFactionTurn(); // Skip if faction is defeated
                    return;
                }

                document.getElementById('turn-text').innerText = `${faction.name}ã®ã‚¿ãƒ¼ãƒ³`;
                document.getElementById('turn-text').className = `text-4xl font-bold italic tracking-wider drop-shadow-[0_2px_2px_rgba(0,0,0,1)] text-white`;
                document.getElementById('turn-text').style.color = faction.color;

                document.getElementById('btn-end-strategic-turn').classList.add('hidden');
                document.getElementById('save-load-group').classList.add('hidden');

                setTimeout(() => {
                    Model.state.aiActionStarted = true;
                    const enemyCastles = Model.state.castles.filter(c => c.owner === faction.id);

                    faction.gold += (100 + enemyCastles.length * 200);

                    // 1. éƒ¨éšŠã®æ–°è¦ç·¨æˆ
                    enemyCastles.forEach(castle => {
                        const unitsAtCastle = Model.state.mapUnits.filter(u => u.owner === faction.id && Math.hypot(u.x - castle.x, u.y - castle.y) < 45);
                        const totalArmies = Model.state.mapUnits.filter(u => u.owner === faction.id).length;
                        const hq = Model.state.castles.find(c => c.id === faction.hqId);

                        const needsNewArmy = (unitsAtCastle.length === 0) || (castle === hq && unitsAtCastle.length < 2);
                        if (needsNewArmy && totalArmies < Model.MAX_ARMIES && faction.gold >= Model.ARMY_COST) {
                            faction.gold -= Model.ARMY_COST;
                            Model.state.mapUnits.push({
                                id: faction.id + '-army-' + Date.now() + Math.random(),
                                owner: faction.id, x: castle.x, y: castle.y, targetX: castle.x, targetY: castle.y,
                                emoji: faction.master.emoji,
                                army: [{ ...Model.FACTION_UNITS[faction.master.id][0], currentHp: Model.FACTION_UNITS[faction.master.id][0].hp, rank: 0, xp: 0 }],
                                isMaster: false, hasActed: true, isMoving: false
                            });
                        }
                    });

                    // 2. ãƒ¦ãƒ‹ãƒƒãƒˆè¿½åŠ 
                    Model.state.mapUnits.filter(u => u.owner === faction.id).forEach(enemyArmy => {
                        const castle = Model.state.castles.find(c => c.owner === faction.id && Math.hypot(c.x - enemyArmy.x, c.y - enemyArmy.y) < 45);
                        if (castle) {
                            let recruitOptions = [...Model.FACTION_UNITS[faction.master.id]];
                            if (castle.uniqueUnit) recruitOptions.push(Model.SPECIAL_UNITS[castle.uniqueUnit]);
                            while (enemyArmy.army.length < Model.MAX_UNITS) {
                                const affordable = recruitOptions.filter(ut => faction.gold >= ut.cost);
                                if (affordable.length === 0) break;
                                affordable.sort((a, b) => b.cost - a.cost);
                                const unitToRecruit = Math.random() > 0.3 ? affordable[0] : affordable[Math.floor(Math.random() * affordable.length)];
                                faction.gold -= unitToRecruit.cost;
                                enemyArmy.army.push({ ...unitToRecruit, currentHp: unitToRecruit.hp, rank: 0, xp: 0 });
                            }
                        }
                    });

                    // 3. ç§»å‹•
                    Model.state.mapUnits.filter(u => u.owner === faction.id).forEach(enemy => {
                        const current = Model.state.castles.find(c => Math.hypot(enemy.x - c.x, enemy.y - c.y) < 45);
                        if (!current) return;
                        const hq = Model.state.castles.find(c => c.id === faction.hqId);
                        const unitsAtHQ = Model.state.mapUnits.filter(u => u.owner === faction.id && Math.hypot(u.x - hq.x, u.y - hq.y) < 45);
                        if (current === hq && unitsAtHQ.length < 2 && Math.random() < 0.7) return;
                        if (unitsAtHQ.length === 0 && current.neighbors.includes(hq.id)) { enemy.targetX = hq.x; enemy.targetY = hq.y; enemy.isMoving = true; return; }

                        if (current.neighbors.length > 0 && Math.random() > 0.4) {
                            const targets = current.neighbors
                                .map(id => Model.state.castles.find(c => c.id === id))
                                .sort((a, b) => {
                                    if (a.owner !== faction.id && b.owner === faction.id) return -1;
                                    if (a.owner === 'player' && b.owner !== 'player') return -1;
                                    return 0;
                                });
                            const next = targets[0];
                            const guards = Model.state.mapUnits.filter(u => u.owner === faction.id && Math.hypot(u.x - next.x, u.y - next.y) < 45);
                            if (next.owner === faction.id && guards.length > 0 && Math.random() > 0.1) return;
                            enemy.targetX = next.x; enemy.targetY = next.y; enemy.isMoving = true;
                        }
                    });
                }, 1000);
            },

            startPlayerTurn() {
                Model.state.turnCount++;
                Model.state.strategicTurn = 'player';

                document.getElementById('turn-text').innerText = "Player Turn";
                document.getElementById('turn-text').className = "text-4xl font-bold italic tracking-wider drop-shadow-[0_2px_2px_rgba(0,0,0,1)] text-white";
                document.getElementById('turn-text').style.color = "";

                document.getElementById('btn-end-strategic-turn').classList.remove('hidden');
                document.getElementById('save-load-group').classList.remove('hidden');

                const player = Model.state.factions.find(f => f.isPlayer);
                const income = 100 + Model.state.castles.filter(c => c.owner === player.id).length * 200;
                player.gold += income;
                Model.state.mapUnits.forEach(u => u.hasActed = false);
                View.showMessage(`ã‚¿ãƒ¼ãƒ³é–‹å§‹ï¼šåå…¥ ${income}G`);
            },

            createNewArmy(castle) {
                const player = Model.state.factions.find(f => f.isPlayer);
                if (player.gold < Model.ARMY_COST) return;
                if (Model.state.mapUnits.filter(u => u.owner === player.id).length >= Model.MAX_ARMIES) {
                    View.showMessage("éƒ¨éšŠæ•°ãŒä¸Šé™ã«é”ã—ã¦ã„ã¾ã™");
                    return;
                }
                player.gold -= Model.ARMY_COST;
                Model.state.mapUnits.push({ id: 'army-' + Date.now(), owner: player.id, x: castle.x, y: castle.y, targetX: castle.x, targetY: castle.y, emoji: player.master.emoji, army: [{ ...Model.FACTION_UNITS[player.master.id][0], currentHp: Model.FACTION_UNITS[player.master.id][0].hp, rank: 0, xp: 0 }], isMaster: false, hasActed: true, isMoving: false });
                View.renderBaseMenu(castle);
            },

            recruitUnit(aId, utId, cId) {
                const player = Model.state.factions.find(f => f.isPlayer);
                const army = Model.state.mapUnits.find(u => u.id === aId);
                const ut = Model.FACTION_UNITS[player.master.id].find(x => x.id === utId) || Model.SPECIAL_UNITS[utId];
                if (army && ut && army.army.length < Model.MAX_UNITS && player.gold >= ut.cost) {
                    player.gold -= ut.cost; army.army.push({ ...ut, currentHp: ut.hp, rank: 0, xp: 0 });
                    View.renderBaseMenu(Model.state.castles.find(c => c.id === cId));
                }
            },

            enhanceUnit(aId, idx, type, cId) {
                const player = Model.state.factions.find(f => f.isPlayer);
                const army = Model.state.mapUnits.find(u => u.id === aId);
                if (!army) return;
                const unit = army.army[idx];
                if (type === 'hp' && player.gold >= 100) { player.gold -= 100; unit.hp += 10; unit.currentHp += 10; }
                else if (type === 'atk' && player.gold >= 150) { player.gold -= 150; unit.atk += 3; }
                View.renderBaseMenu(Model.state.castles.find(c => c.id === cId));
            },

            startBattle() {
                window.gameState = Model.state;
                View.changeScreen('battle');
                this.initBattleGrid();
            },

            initBattleGrid() {
                const grid = document.getElementById('battle-grid'); grid.innerHTML = '';
                const cols = 7, rows = 6, hexSize = 90;
                Model.state.battle.grid = [];
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        // æ¨™æº–çš„ãªãƒã‚¤ãƒ³ãƒˆãƒˆãƒƒãƒ—ãƒ»ãƒ˜ãƒƒã‚¯ã‚¹ã®é…ç½®è¨ˆç®—
                        const x = c * hexSize + (r % 2 ? hexSize / 2 : 0);
                        const y = r * hexSize * 0.75;
                        const hex = document.createElement('div');
                        hex.className = 'hex hex-active absolute bg-slate-800/60 border border-slate-700 flex items-center justify-center transition-all duration-200 shadow-inner';
                        hex.style.width = `${hexSize}px`; hex.style.height = `${hexSize}px`; hex.style.left = `${x}px`; hex.style.top = `${y}px`;
                        hex.onclick = () => this.handleBattleHexClick(r, c);
                        hex.oncontextmenu = (e) => { e.preventDefault(); this.handleBattleUnitRightClick(r, c); };
                        grid.appendChild(hex); Model.state.battle.grid.push({ r, c, el: hex });
                    }
                }
                grid.style.width = `${(cols + 0.5) * hexSize}px`; grid.style.height = `${(rows * 0.75 + 0.25) * hexSize}px`;
                const pU = Model.state.battleUnitA.army.map((u, i) => ({ ...u, r: 1 + i, c: 0, owner: 'player' })), eU = Model.state.battleUnitB.army.map((u, i) => ({ ...u, r: 1 + i, c: 6, owner: 'enemy' }));
                Model.state.battle.units = [...pU, ...eU]; Model.state.battle.movedUnits = new Set(); Model.state.battle.selectedUnit = null; Model.state.battle.tempMoved = false; Model.state.battle.turn = 'player'; Model.state.battle.active = true;
                View.updateBattleUI();
            },

            handleBattleHexClick(r, c) {
                const b = Model.state.battle; if (b.turn !== 'player' || !b.active) return;
                const target = b.units.find(u => u.r === r && u.c === c);
                if (b.selectedUnit && b.tempMoved) {
                    const s = b.selectedUnit; const d = Model.getHexDist(s.r, s.c, r, c);
                    if (target && target.owner === 'enemy' && d <= s.range) {
                        if (s.range > 1) View.showMessage("é è·é›¢ã¯ç§»å‹•å‰ã®ã¿"); else this.battleAttack(s, target);
                    } else { b.movedUnits.add(s); b.selectedUnit = null; b.tempMoved = false; if (target && target.owner === 'player' && !b.movedUnits.has(target)) b.selectedUnit = target; }
                    View.updateBattleUI(); return;
                }
                if (target && target.owner === 'player') { if (!b.movedUnits.has(target)) { b.selectedUnit = target; b.tempMoved = false; } View.updateBattleUI(); return; }
                if (b.selectedUnit) {
                    const s = b.selectedUnit, d = Model.getHexDist(s.r, s.c, r, c);
                    if (target && target.owner === 'enemy') { if (d <= s.range) this.battleAttack(s, target); }
                    else if (!target && d <= s.move) { s.r = r; s.c = c; b.tempMoved = true; }
                    else { b.selectedUnit = null; }
                }
                View.updateBattleUI(); this.checkBattleEnd();
            },

            handleBattleUnitRightClick(r, c) {
                const b = Model.state.battle; if (!b.active) return;
                const u = b.units.find(u => u.r === r && u.c === c);
                if (u) {
                    const rank = Model.RANKS[u.rank || 0];
                    const xpText = u.rank === 5 ? "MAX" : `${u.xp || 0} / ${Model.RANK_UP_XP}`;
                    const statusText = `ã€${u.name}ã€‘ (${u.owner === 'player' ? 'è‡ªè»' : 'æ•µè»'})
 RANK: ${rank} (XP: ${xpText})
 HP: ${u.currentHp} / ${u.hp}  ATK: ${u.atk}
 RANGE: ${u.range}  MOVE: ${u.move}`;
                    View.showMessage(statusText);
                }
            },

            battleAttack(atk, def) {
                const dmg = Math.floor(atk.atk * (0.8 + Math.random() * 0.4)); def.currentHp -= dmg;
                View.showMessage(`${atk.name}ã®æ”»æ’ƒï¼ ${def.name}ã«${dmg}ãƒ€ãƒ¡ï¼`);

                // XPç²å¾—
                this.gainXp(atk, 10);

                Model.state.battle.movedUnits.add(atk); Model.state.battle.selectedUnit = null; Model.state.battle.tempMoved = false;
                if (def.currentHp <= 0) {
                    this.gainXp(atk, 30); // æ’ƒç ´ãƒœãƒ¼ãƒŠã‚¹
                    Model.state.battle.units = Model.state.battle.units.filter(u => u !== def);
                }
            },

            gainXp(unit, amount) {
                if (unit.rank === 5) return; // Sãƒ©ãƒ³ã‚¯ã¯æˆé•·åœæ­¢
                if (!unit.xp && unit.xp !== 0) { unit.xp = 0; unit.rank = 0; }
                unit.xp += amount;
                if (unit.xp >= Model.RANK_UP_XP) {
                    unit.xp -= Model.RANK_UP_XP;
                    unit.rank++;

                    // å„èƒ½åŠ›ã®ãã®æ™‚ç‚¹ã®å€¤ã®20%å‘ä¸Š
                    const hpBonus = Math.max(1, Math.floor(unit.hp * 0.2));
                    const atkBonus = Math.max(1, Math.floor(unit.atk * 0.2));

                    unit.hp += hpBonus;
                    unit.currentHp += hpBonus;
                    unit.atk += atkBonus;

                    View.showMessage(`${unit.name}ãŒãƒ©ãƒ³ã‚¯ã‚¢ãƒƒãƒ—ï¼ RANK ${Model.RANKS[unit.rank]}ã«ãªã£ãŸï¼\n(HP+${hpBonus}, ATK+${atkBonus})`);
                    if (unit.rank === 5) { unit.xp = 0; } // Sãƒ©ãƒ³ã‚¯åˆ°é”
                }
            },

            battleEndTurnOrder() {
                const b = Model.state.battle; if (!b.active || b.turn !== 'player') return;
                if (b.selectedUnit && b.tempMoved) b.movedUnits.add(b.selectedUnit);
                b.selectedUnit = null; b.tempMoved = false; b.turn = 'enemy'; b.movedUnits.clear();
                View.updateBattleUI(); setTimeout(() => this.enemyBattleTurn(), 800);
            },

            enemyBattleTurn() {
                const b = Model.state.battle; if (!b.active) return;
                Model.state.battle.units.filter(u => u.owner === 'enemy').forEach(e => {
                    const targets = Model.state.battle.units.filter(u => u.owner === 'player');
                    if (targets.length > 0) {
                        const t = targets[0], d = Model.getHexDist(e.r, e.c, t.r, t.c);
                        if (d <= e.range) this.battleAttack(e, t);
                        else {
                            let nR = e.r, nC = e.c;
                            if (e.r > t.r) nR--; else if (e.r < t.r) nR++;
                            if (e.c > t.c) nC--; else if (e.c < t.c) nC++;
                            if (!b.units.some(u => u.r === nR && u.c === nC)) { e.r = nR; e.c = nC; }
                            if (Model.getHexDist(e.r, e.c, t.r, t.c) <= e.range) this.battleAttack(e, t);
                            b.movedUnits.add(e);
                        }
                    }
                });
                this.checkBattleEnd();
                if (b.active) { b.turn = 'player'; b.movedUnits.clear(); View.updateBattleUI(); View.showMessage("ã‚ãªãŸã®ã‚¿ãƒ¼ãƒ³ã§ã™"); }
            },

            checkBattleEnd() {
                const b = Model.state.battle; if (!b.active) return;
                const pC = b.units.filter(u => u.owner === 'player').length, eC = b.units.filter(u => u.owner === 'enemy').length;
                if (eC === 0) { b.active = false; View.openModal("VICTORY", "å‹åˆ©ï¼", [{ label: "ç¶šè¡Œ", action: () => this.finishBattle(true) }]); }
                else if (pC === 0) { b.active = false; View.openModal("æ•—åŒ—", "å…¨æ»…ã—ãŸ...", [{ label: "å¸°é‚„", action: () => this.finishBattle(false) }]); }
            },

            autoResolveBattle(u1, u2) {
                const p1 = u1.army.reduce((sum, unit) => sum + unit.atk, 0) * (u1.army.length / 5 + 0.5);
                const p2 = u2.army.reduce((sum, unit) => sum + unit.atk, 0) * (u2.army.length / 5 + 0.5);

                // ä¸¡è»ã«ãƒ€ãƒ¡ãƒ¼ã‚¸
                u1.army.forEach(u => u.currentHp -= Math.floor(p2 / u1.army.length * (0.5 + Math.random())));
                u2.army.forEach(u => u.currentHp -= Math.floor(p1 / u2.army.length * (0.5 + Math.random())));

                u1.army = u1.army.filter(u => u.currentHp > 0);
                u2.army = u2.army.filter(u => u.currentHp > 0);

                u1.army.forEach(u => u.currentHp -= Math.floor(p2 / u1.army.length * (0.5 + Math.random())));
                u2.army.forEach(u => u.currentHp -= Math.floor(p1 / u2.army.length * (0.5 + Math.random())));

                u1.army = u1.army.filter(u => u.currentHp > 0);
                u2.army = u2.army.filter(u => u.currentHp > 0);

                const f1 = Model.state.factions.find(f => f.id === u1.owner);
                const f2 = Model.state.factions.find(f => f.id === u2.owner);

                if (u1.army.length === 0 && u2.army.length === 0) {
                    View.showMessage(`æ¿€æˆ¦ã®æœ«ã€${f1.name}ã¨${f2.name}ã¯ç›¸æ‰“ã¡ã¨ãªã‚Šå…±ã«æ¶ˆæ»…ã—ã¾ã—ãŸï¼`);
                    Model.state.mapUnits = Model.state.mapUnits.filter(u => u !== u1 && u !== u2);
                } else if (u1.army.length === 0) {
                    View.showMessage(`${f1.name}ã¯æ•—åŒ—ã—ã€${f2.name}ãŒå‹åˆ©ã—ã¾ã—ãŸï¼`);
                    Model.state.mapUnits = Model.state.mapUnits.filter(u => u !== u1);
                } else if (u2.army.length === 0) {
                    View.showMessage(`${f2.name}ã¯æ•—åŒ—ã—ã€${f1.name}ãŒå‹åˆ©ã—ã¾ã—ãŸï¼`);
                    Model.state.mapUnits = Model.state.mapUnits.filter(u => u !== u2);
                } else {
                    View.showMessage(`${f1.name}ã¨${f2.name}ã®å°ç«¶ã‚Šåˆã„ãŒç™ºç”Ÿã—ã¾ã—ãŸï¼`);
                }

                Model.state.globalBattleCooldown = 40;

                // ãƒãƒˆãƒ«ãŒç™ºç”Ÿã—ãŸå ´æ‰€ãŒæ‹ ç‚¹ãªã‚‰ã€æ•—åŒ—ã—ãŸå´ã®ãƒ¦ãƒ‹ãƒƒãƒˆãŒæ¶ˆæ»…ã—ãŸå¾Œã«æ‹ ç‚¹ã®åˆ¶åœ§ãƒã‚§ãƒƒã‚¯ã‚’å‘¼ã¶å¿…è¦ãŒã‚ã‚‹
                // updateLogicã®ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ—ã§åˆ¤å®šã•ã‚Œã‚‹ãŒã€å³æ™‚ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å‡ºã™ãŸã‚ã«ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹ç­‰ã®å‡¦ç†ã¯ä¸è¦
            },

            finishBattle(win) {
                const pA = Model.state.battleUnitA;
                pA.hasActed = true; // æˆ¦é—˜çµ‚äº†å¾Œã«è¡Œå‹•æ¸ˆã¿ã¨ã™ã‚‹
                if (win) {
                    Model.state.mapUnits = Model.state.mapUnits.filter(u => u !== Model.state.battleUnitB);
                    // ç”Ÿãæ®‹ã£ãŸãƒ¦ãƒ‹ãƒƒãƒˆã‚’å…¨å›å¾©ã•ã›ã¦å¼•ãç¶™ã
                    pA.army = Model.state.battle.units.filter(u => u.owner === 'player').map(u => ({ ...u, currentHp: u.hp }));
                } else {
                    // æœ¬æ‹ åœ°ï¼ˆHQï¼‰ã§ã®æ•—åŒ—ãƒ»æ’¤é€€ã¯å³åº§ã«ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼
                    const castleAtPos = Model.state.castles.find(c => Math.hypot(pA.x - c.x, pA.y - c.y) < 45);
                    const playerFaction = Model.state.factions.find(f => f.isPlayer);
                    const atHQ = castleAtPos && castleAtPos.id === playerFaction.hqId;

                    if (atHQ) {
                        Model.state.gameCleared = true;
                        View.showEnding(false);
                        return;
                    }

                    // æ•—åŒ—æ™‚ã¯ãƒšãƒŠãƒ«ãƒ†ã‚£ã¨ã—ã¦åˆæœŸãƒ¦ãƒ‹ãƒƒãƒˆ1ä½“ã§å¾©æ´»ï¼ˆHPå…¨é–‹ï¼‰
                    pA.army = [{ ...Model.FACTION_UNITS[playerFaction.master.id][0], currentHp: Model.FACTION_UNITS[playerFaction.master.id][0].hp, rank: 0, xp: 0 }];
                    const hq = Model.state.castles.find(c => c.id === playerFaction.hqId);
                    if (hq) {
                        // ã‚‚ã—æœ¬æ‹ åœ°ãŒæ—¢ã«æ•µã«å é ˜ã•ã‚Œã¦ã„ãŸã‚‰æ•—åŒ—
                        if (hq.owner !== playerFaction.id) {
                            Model.state.gameCleared = true;
                            View.showEnding(false);
                            return;
                        }
                        pA.x = hq.x; pA.y = hq.y; pA.targetX = hq.x; pA.targetY = hq.y;
                    }
                }
                Model.state.globalBattleCooldown = 60; Model.state.battle.active = false; View.changeScreen('map');
            },

            showEscapeConfirm() { View.openModal("æ’¤é€€ç¢ºèª", "æˆ¦å ´ã‹ã‚‰é›¢è„±ã—ã¾ã™ã‹ï¼Ÿ", [{ label: "ã¯ã„", action: () => this.finishBattle(false) }, { label: "ã„ã„ãˆ", action: () => { } }]); },

            saveGame() {
                const saveState = JSON.parse(JSON.stringify(Model.state));
                saveState.battle.grid = [];
                if (Model.state.battle.movedUnits) {
                    saveState.battle.movedUnitsIndices = [...Model.state.battle.movedUnits].map(u => Model.state.battle.units.indexOf(u));
                }
                localStorage.setItem('bahamut_save', JSON.stringify(saveState));
                View.showMessage("ã‚·ã‚¹ãƒ†ãƒ ï¼šé€²è¡ŒçŠ¶æ³ã‚’ã‚»ãƒ¼ãƒ–ã—ã¾ã—ãŸ");
            },

            loadGame() {
                const data = localStorage.getItem('bahamut_save');
                if (!data) { View.showMessage("ã‚¨ãƒ©ãƒ¼ï¼šã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"); return; }
                const state = JSON.parse(data);
                if (state.battle.movedUnitsIndices) {
                    state.battle.movedUnits = new Set(state.battle.movedUnitsIndices.map(i => state.battle.units[i]));
                } else {
                    state.battle.movedUnits = new Set();
                }
                Model.state = state;
                View.changeScreen(Model.state.currentScreen);
                if (Model.state.currentScreen === 'map') {
                    View.initCanvas();
                } else if (Model.state.currentScreen === 'battle') {
                    this.initBattleGrid();
                }
                const player = Model.state.factions.find(f => f.isPlayer);
                if (player) {
                    document.getElementById('master-name').innerText = player.master.name;
                    document.getElementById('master-name').style.color = player.master.color;
                    document.getElementById('master-alignment').innerText = player.master.alignment;
                }
                const turns = Model.state.strategicTurn !== 'player';
                document.getElementById('turn-text').innerText = turns ? (Model.state.factions.find(f => f.id === Model.state.strategicTurn)?.name + " Turn") : "Player Turn";
                document.getElementById('turn-text').classList.toggle('text-red-500', turns);
                document.getElementById('btn-end-strategic-turn').classList.toggle('hidden', turns);
                document.getElementById('save-load-group').classList.toggle('hidden', turns);
                View.showMessage("ã‚·ã‚¹ãƒ†ãƒ ï¼šã‚²ãƒ¼ãƒ ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¾ã—ãŸ");
            }
        };

        /**
         * TEST SUITE: ã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆ
         */
        const TestSuite = {
            logs: [],
            assert(condition, message) {
                this.logs.push(`${condition ? 'âœ… PASS' : 'âŒ FAIL'}: ${message}`);
                return condition ? 1 : 0;
            },

            runAll() {
                this.logs = [];
                let passed = 0, total = 0;

                console.log("--- Starting System Tests ---");

                // å®Ÿè¡Œå‰ã®çŠ¶æ…‹ã‚’ä¿å­˜
                const originalFactions = JSON.parse(JSON.stringify(Model.state.factions));
                const originalUnits = [...Model.state.mapUnits];
                const originalCastles = JSON.parse(JSON.stringify(Model.state.castles));

                // é€²è¡ŒçŠ¶æ…‹ã§ãªã‘ã‚Œã°ãƒ†ã‚¹ãƒˆç”¨ã«æœ€å°é™ã®åˆæœŸåŒ–ã‚’è¡Œã†
                if (Model.state.factions.length === 0) {
                    Model.state.factions = [
                        { id: 'player', name: 'è‡ªè»', gold: 500, master: Model.MASTERS[0], color: '#44aaff', isPlayer: true, isAlive: true, hqId: 'c1' },
                        { id: 'enemy', name: 'æ•µè»', gold: 500, master: Model.MASTERS[1], color: '#ff4444', isPlayer: false, isAlive: true, hqId: 'c2' }
                    ];
                }

                // 1. è·é›¢è¨ˆç®—ã®ãƒ†ã‚¹ãƒˆ
                total++; passed += this.assert(Model.getHexDist(0, 0, 0, 1) === 1, "Hex Distance: Adjacent");
                total++; passed += this.assert(Model.getHexDist(0, 0, 2, 2) === 3, "Hex Distance: Diagonal (0,0 to 2,2 is 3 steps)");
                total++; passed += this.assert(Model.getHexDist(0, 0, 5, 0) === 5, "Hex Distance: Far");

                // 2. åº§æ¨™å¤‰æ›ã®ãƒ†ã‚¹ãƒˆ
                const cube = Model.getCubeCoords(2, 2);
                total++; passed += this.assert(cube.x + cube.y + cube.z === 0, "Cube Coordinates: Sum is zero");

                // 3. è³‡é‡‘ç®¡ç†ã¨é›‡ç”¨åˆ¶é™ã®ãƒ†ã‚¹ãƒˆ
                const player = Model.state.factions.find(f => f.isPlayer);
                if (!player) { View.showMessage("ãƒ†ã‚¹ãƒˆå¤±æ•—: ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å‹¢åŠ›ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"); return; }

                // ãƒ¢ãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿è¨­å®š
                player.master = Model.MASTERS[0]; // knight
                player.gold = 400; // 500Gæœªæº€ã«è¨­å®š
                const mockCastle = { x: 0, y: 0, id: 'test-c' };

                Controller.createNewArmy(mockCastle);
                total++; passed += this.assert(Model.state.mapUnits.length === originalUnits.length, "Create Army: Should fail if insufficient gold");

                player.gold = 1000;
                Controller.createNewArmy(mockCastle);
                total++; passed += this.assert(Model.state.mapUnits.length === originalUnits.length + 1, "Create Army: Should succeed if enough gold");
                total++; passed += this.assert(player.gold === 500, "Create Army: Gold should be deducted");

                // æœ€å¤§éƒ¨éšŠæ•°åˆ¶é™ã®ãƒ†ã‚¹ãƒˆ
                player.gold = 10000;
                while (Model.state.mapUnits.length < Model.MAX_ARMIES) { Controller.createNewArmy(mockCastle); }
                const countBefore = Model.state.mapUnits.length;
                Controller.createNewArmy(mockCastle);
                total++; passed += this.assert(Model.state.mapUnits.length === countBefore, "Create Army: Should not exceed MAX_ARMIES");

                // 4. åå…¥è¨ˆç®—ã®ãƒ†ã‚¹ãƒˆ
                player.gold = 0;
                Model.state.castles = [
                    { owner: 'player' }, { owner: 'player' }, { owner: 'enemy' }
                ];
                Controller.startPlayerTurn();
                // 100(åŸºæœ¬) + 2(åŸæ•°) * 200 = 500
                total++; passed += this.assert(player.gold === 500, `Income Calculation: Expected 500, got ${player.gold}`);

                // 5. å‹åˆ©ãƒ»æ•—åŒ—åˆ¤å®šã®ãƒ†ã‚¹ãƒˆ
                Model.state.gameCleared = false;
                // å…¨ã¦ã®æ•µå‹¢åŠ›ã‚’æ»…äº¡ã•ã›ã‚‹
                Model.state.factions.forEach(f => { if (!f.isPlayer) f.isAlive = false; });
                Controller.checkWinCondition();
                total++; passed += this.assert(Model.state.gameCleared === true, "Win Condition: All enemies are dead");

                Model.state.gameCleared = false;
                Model.state.factions.forEach(f => { if (!f.isPlayer) f.isAlive = true; });
                Model.state.castles = [{ owner: 'enemy' }, { owner: 'neutral' }]; // è‡ªè»æ‹ ç‚¹ãŒ0
                Controller.checkWinCondition();
                total++; passed += this.assert(Model.state.gameCleared === true, "Lose Condition: Player castles are zero");

                // 6. ã‚¿ãƒ¼ãƒ³ãƒªã‚»ãƒƒãƒˆã¨è¡Œå‹•ãƒ•ãƒ©ã‚°ã®ãƒ†ã‚¹ãƒˆ
                const mockArmy = { hasActed: false, owner: 'player', x: 0, y: 0, targetX: 0, targetY: 0, army: [] };
                Model.state.battleUnitA = mockArmy;
                Model.state.battleUnitB = { owner: 'enemy', army: [] };
                Controller.finishBattle(true);
                total++; passed += this.assert(mockArmy.hasActed === true, "Action Flag: Unit should be 'acted' after battle");

                // ã‚¿ãƒ¼ãƒ³é–‹å§‹æ™‚ã®ãƒªã‚»ãƒƒãƒˆãƒ†ã‚¹ãƒˆ
                Model.state.mapUnits = [
                    { hasActed: true, owner: 'player' },
                    { hasActed: true, owner: 'player' },
                    { hasActed: false, owner: 'enemy' }
                ];
                Controller.startPlayerTurn();
                total++; passed += this.assert(Model.state.mapUnits[0].hasActed === false, "Turn Reset: Player unit 1 should be reset");
                total++; passed += this.assert(Model.state.mapUnits[1].hasActed === false, "Turn Reset: Player unit 2 should be reset");

                // ç’°å¢ƒã®å¾©å…ƒ
                Model.state.factions = originalFactions;
                Model.state.mapUnits = originalUnits;
                Model.state.castles = originalCastles;
                Model.state.gameCleared = false;
                Model.state.battleUnitA = null;
                Model.state.battleUnitB = null;

                // çµæœã®è¡¨ç¤º
                this.logs.forEach(log => console.log(log));
                console.log(`--- Test Results: ${passed}/${total} passed ---`);
                View.showMessage(`ãƒ†ã‚¹ãƒˆå®Œäº†: ${passed}/${total} åˆæ ¼ã€‚è©³ç´°ã¯ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚`);
            }
        };

        window.onload = () => { Controller.init(); View.changeScreen('title'); };
        window.onresize = () => { if (Model.state.currentScreen === 'map') View.initCanvas(); };
    </script>
</body>

</html>